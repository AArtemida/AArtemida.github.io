<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>D3学习记录</title>
    <url>/2018/03/02/D3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>学习笔记(๑•ั็ω•็ั๑) 基本上来自于参考网站，方便以后查阅。</p><a id="more"></a><h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><p>在 D3 中，用于选择元素的函数有两个：</p><ul><li>d3.select()：是选择所有指定元素的第一个&#x2F;&#x2F;如果选择多个可以加class名</li><li>d3.selectAll()：是选择指定元素的全部</li></ul><p>这两个函数返回的结果称为选择集。例如，选择集的常见用法如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>); <span class="comment">//选择文档中的body元素</span></span><br><span class="line"><span class="keyword">var</span> p1 = body.select(<span class="string">"p"</span>);      <span class="comment">//选择body中的第一个p元素</span></span><br><span class="line"><span class="keyword">var</span> p = body.selectAll(<span class="string">"p"</span>);    <span class="comment">//选择body中的所有p元素</span></span><br><span class="line"><span class="keyword">var</span> svg = body.select(<span class="string">"svg"</span>);   <span class="comment">//选择body中的svg元素</span></span><br><span class="line"><span class="keyword">var</span> rects = svg.selectAll(<span class="string">"rect"</span>);  <span class="comment">//选择svg中所有的svg元素</span></span><br></pre></td></tr></table></figure><p>选择集和绑定数据通常是一起使用的。</p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>D3 有一个很独特的功能：能将数据绑定到 DOM 上，也就是绑定到文档上。D3 中是通过以下两个函数来绑定数据的：</p><ul><li>datum()：绑定一个数据到选择集上</li><li>data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</li></ul><h4 id="datum"><a href="#datum" class="headerlink" title="datum()"></a>datum()</h4><p>假设有一字符串 China，要将此字符串分别与三个段落元素绑定，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"China"</span>;</span><br><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.selectAll(<span class="string">"p"</span>);</span><br><span class="line">p.datum(str);</span><br><span class="line">p.text(<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"第 "</span>+ i + <span class="string">" 个元素绑定的数据是 "</span> + d;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>绑定数据后，使用此数据来修改三个段落元素的内容，其结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第 0 个元素绑定的数据是 China</span><br><span class="line">第 1 个元素绑定的数据是 China</span><br><span class="line">第 2 个元素绑定的数据是 China</span><br></pre></td></tr></table></figure><p>在上面的代码中，用到了一个无名函数 function(d, i)。当选择集需要使用被绑定的数据时，常需要这么使用。其包含两个参数，其中：</p><ul><li>d 代表数据，也就是与某元素绑定的数据。</li><li>i 代表索引，代表数据的索引号，从 0 开始。</li></ul><p>例如，上述例子中：第 0 个元素 apple 绑定的数据是 China。</p><h4 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h4><p>有一个数组，接下来要分别将数组的各元素绑定到三个段落元素上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="string">"I like dogs"</span>,<span class="string">"I like cats"</span>,<span class="string">"I like snakes"</span>];</span><br></pre></td></tr></table></figure><p>绑定之后，其对应关系的要求为：</p><ul><li>Apple 与 I like dogs 绑定</li><li>Pear 与 I like cats 绑定</li><li>Banana 与 I like snakes 绑定</li></ul><p>调用 data() 绑定数据，并替换三个段落元素的字符串为被绑定的字符串，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">"body"</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.selectAll(<span class="string">"p"</span>);</span><br><span class="line">p.data(dataset)</span><br><span class="line">  .text(<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这段代码也用到了一个无名函数 function(d, i)，其对应的情况如下：</p><ul><li>当 i &#x3D;&#x3D; 0 时， d 为 I like dogs。</li><li>当 i &#x3D;&#x3D; 1 时， d 为 I like cats。</li><li>当 i &#x3D;&#x3D; 2 时， d 为 I like snakes。</li></ul><p>此时，三个段落元素与数组 dataset 的三个字符串是一一对应的，因此，在函数 function(d, i) 直接 return d 即可。</p><p>结果自然是三个段落的文字分别变成了数组的三个字符串。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I like dogs</span><br><span class="line">I like cats</span><br><span class="line">I like snakes</span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>插入元素涉及的函数有两个：</p><ul><li>append()：在选择集末尾插入元素</li><li>insert()：在选择集前面插入元素</li></ul><p>假设有三个段落元素，与上文相同。</p><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body.append(<span class="string">"p"</span>).text(<span class="string">"append p element"</span>);</span><br><span class="line"><span class="comment">//在 body 的末尾添加一个 p 元素，结果为：</span></span><br><span class="line">Apple</span><br><span class="line">Pear</span><br><span class="line">Banana</span><br><span class="line">append p element</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>在 body 中 id 为 myid 的元素前添加一个段落元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body.insert(<span class="string">"p"</span>,<span class="string">"#myid"</span>).text(<span class="string">"insert p element"</span>);</span><br><span class="line"><span class="comment">//已经指定了 Pear 段落的 id 为 myid，因此结果如下。</span></span><br><span class="line">Apple</span><br><span class="line">insert p element</span><br><span class="line">Pear</span><br><span class="line">Banana</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除一个元素时，对于选择的元素，使用 remove 即可，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = body.select(<span class="string">"#myid"</span>);</span><br><span class="line">p.remove();</span><br></pre></td></tr></table></figure><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><h4 id="SVG-是什么"><a href="#SVG-是什么" class="headerlink" title="SVG 是什么"></a>SVG 是什么</h4><p>SVG，指可缩放矢量图形（Scalable Vector Graphics），是用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开放标准。SVG 使用 XML 格式来定义图形，除了 IE8 之前的版本外，绝大部分浏览器都支持 SVG，可将 SVG 文本直接嵌入 HTML 中显示。SVG 有如下特点：</p><ul><li>SVG 绘制的是矢量图，因此对图像进行放大不会失真。</li><li>基于 XML，可以为每个元素添加 JavaScript 事件处理器。</li><li>每个图形均视为对象，更改对象的属性，图形也会改变。</li><li>不适合游戏应用。</li></ul><h4 id="Canvas-是什么"><a href="#Canvas-是什么" class="headerlink" title="Canvas 是什么"></a>Canvas 是什么</h4><p>Canvas 是通过 JavaScript 来绘制 2D 图形，是 HTML 5 中新增的元素。<br>Canvas 有如下特点：</p><ul><li>绘制的是位图，图像放大后会失真。</li><li>不支持事件处理器。</li><li>能够以 .png 或 .jpg 格式保存图像</li><li>适合游戏应用</li></ul><h4 id="添加画布"><a href="#添加画布" class="headerlink" title="添加画布"></a>添加画布</h4><p>使用 D3 在 body 元素中添加 svg 的代码如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="number">300</span>;  <span class="comment">//画布的宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">300</span>;   <span class="comment">//画布的高度</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">"body"</span>)     <span class="comment">//选择文档中的body元素</span></span><br><span class="line">    .append(<span class="string">"svg"</span>)          <span class="comment">//添加一个svg元素</span></span><br><span class="line">    .attr(<span class="string">"width"</span>, width)       <span class="comment">//设定宽度</span></span><br><span class="line">    .attr(<span class="string">"height"</span>, height);    <span class="comment">//设定高度</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ourd3js.com/wordpress/" target="_blank" rel="noopener">http://www.ourd3js.com/wordpress/</a></p>]]></content>
      <categories>
        <category>笔记</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>D3学习记录3</title>
    <url>/2018/03/06/D3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h3 id="实现动态的方法"><a href="#实现动态的方法" class="headerlink" title="实现动态的方法"></a>实现动态的方法</h3><p>动态的图表，是指图表在某一时间段会发生某种变化，可能是形状、颜色、位置等，而且用户是可以看到变化的过程的。（过渡）</p><a id="more"></a><p>D3 提供了 4 个方法用于实现图形的过渡：从状态 A 变为状态 B。</p><h4 id="transition"><a href="#transition" class="headerlink" title="transition()"></a>transition()</h4><p>启动过渡效果。<br>其前后是图形变化前后的状态（形状、位置、颜色等等），例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.attr(<span class="string">"fill"</span>,<span class="string">"red"</span>)         <span class="comment">//初始颜色为红色</span></span><br><span class="line">.transition()               <span class="comment">//启动过渡</span></span><br><span class="line">.attr(<span class="string">"fill"</span>,<span class="string">"steelblue"</span>)   <span class="comment">//终止颜色为铁蓝色</span></span><br></pre></td></tr></table></figure><p>D3 会自动对两种颜色（红色和铁蓝色）之间的颜色值（RGB值）进行插值计算，得到过渡用的颜色值。</p><h4 id="duration"><a href="#duration" class="headerlink" title="duration()"></a>duration()</h4><p>指定过渡的持续时间，单位为毫秒。如 duration(2000) ，指持续 2000 毫秒，即 2 秒。</p><h4 id="ease"><a href="#ease" class="headerlink" title="ease()"></a>ease()</h4><p>指定过渡的方式，常用的有：</p><ul><li>linear：普通的线性变化</li><li>circle：慢慢地到达变换的最终状态</li><li>elastic：带有弹跳的到达最终状态</li><li>bounce：在最终状态处弹跳几次</li></ul><p>调用时，格式形如： ease(“bounce”)。</p><h4 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h4><p>指定延迟的时间，表示一定时间后才开始转变，单位同样为毫秒。此函数可以对整体指定延迟，也可以对个别指定延迟。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对整体指定时：</span></span><br><span class="line">.transition()</span><br><span class="line">.duration(<span class="number">1000</span>)</span><br><span class="line">.delay(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>图形整体在延迟 500 毫秒后发生变化，变化的时长为 1000 毫秒。因此，过渡的总时长为1500毫秒。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对一个一个的图形（图形上绑定了数据）进行指定时：</span></span><br><span class="line">.transition()</span><br><span class="line">.duration(<span class="number">1000</span>)</span><br><span class="line">.delay(funtion(d,i)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>*i;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如此，假设有 10 个元素，那么第 1 个元素延迟 0 毫秒（因为 i &#x3D; 0），第 2 个元素延迟 200 毫秒，第 3 个延迟 400 毫秒，依次类推….整个过渡的长度为 200 * 9 + 1000 &#x3D; 2800 毫秒。</p><h3 id="Update、Enter、Exit"><a href="#Update、Enter、Exit" class="headerlink" title="Update、Enter、Exit"></a>Update、Enter、Exit</h3><p>如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到三个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 <font color="#63ca87">Enter</font>。而有元素与数据对应的部分称为 <font color="#63ca87">Update</font>。如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 <font color="#63ca87">Exit</font>。</p><h4 id="Update-和-Enter-的使用"><a href="#Update-和-Enter-的使用" class="headerlink" title="Update 和 Enter 的使用"></a>Update 和 Enter 的使用</h4><p>当对应的元素不足时 （ 绑定数据数量 &gt; 对应元素 ），需要添加元素（append）。</p><ul><li>update 部分的处理办法一般是：更新属性值</li><li>enter 部分的处理办法一般是：添加元素后，赋予属性值</li></ul><h4 id="Update-和-Exit-的使用"><a href="#Update-和-Exit-的使用" class="headerlink" title="Update 和 Exit 的使用"></a>Update 和 Exit 的使用</h4><p>当对应的元素过多时 （ 绑定数据数量 &lt; 对应元素 ），需要删掉多余的元素。</p><ul><li>exit 部分的处理办法一般是：删除元素（remove）</li></ul><h3 id="交互式操作"><a href="#交互式操作" class="headerlink" title="交互式操作"></a>交互式操作</h3><p>交互，指的是用户输入了某种指令，程序接受到指令之后必须做出某种响应。对可视化图表来说，交互能使图表更加生动，能表现更多内容。例如，拖动图表中某些图形、鼠标滑到图形上出现提示框、用触屏放大或缩小图形等等。</p><p>用户用于交互的工具一般有三种：鼠标、键盘、触屏。</p><p>在 D3 中，每一个选择集都有 on() 函数，用于添加事件监听器。<br>on() 的第一个参数是监听的事件，第二个参数是监听到事件后响应的内容，第二个参数是一个函数。</p><p>鼠标常用的事件有：</p><ul><li>click：鼠标单击某元素时，相当于 mousedown 和 mouseup 组合在一起。</li><li>mouseover：光标放在某元素上。</li><li>mouseout：光标从某元素上移出来时。</li><li>mousemove：鼠标被移动的时候。</li><li>mousedown：鼠标按钮被按下。</li><li>mouseup：鼠标按钮被松开。</li><li>dblclick：鼠标双击。</li></ul><p>键盘常用的事件有三个：</p><ul><li>keydown：当用户按下任意键时触发，按住不放会重复触发此事件。该事件不会区分字母的大小写，例如“A”和“a”被视为一致。</li><li>keypress：当用户按下字符键（大小写字母、数字、加号、等号、回车等）时触发，按住不放会重复触发此事件。该事件区分字母的大小写。</li><li>keyup：当用户释放键时触发，不区分字母的大小写。</li></ul><p>触屏常用的事件有三个：</p><ul><li>touchstart：当触摸点被放在触摸屏上时。</li><li>touchmove：当触摸点在触摸屏上移动时。</li><li>touchend：当触摸点从触摸屏上拿开时。</li></ul><p>当某个事件被监听到时，D3 会把当前的事件存到 d3.event 对象，里面保存了当前事件的各种参数。如果需要监听到事件后立刻输出该事件，可以添加一行代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">circle.on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d3.event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>将不适合用于绘图的数据转换成了适合用于绘图的数据。暂且将布局的作用称为数据转换。</p><p>D3 总共提供了 12 个布局：饼状图（Pie）、力导向图（Force）、弦图（Chord）、树状图（Tree）、集群图（Cluster）、捆图（Bundle）、打包图（Pack）、直方图（Histogram）、分区图（Partition）、堆栈图（Stack）、矩阵树图（Treemap）、层级图（Hierarchy）。</p><p>12 个布局中，层级图（Hierarchy）不能直接使用。集群图、打包图、分区图、树状图、矩阵树图是由层级图扩展来的。如此一来，能够使用的布局是 11 个（有 5 个是由层级图扩展而来）。这些布局的作用都是将某种数据转换成另一种数据，而转换后的数据是利于可视化的。</p><blockquote><p>布局不是要直接绘图，而是为了得到绘图所需的数据。</p></blockquote><p>为了根据转换后的数据 piedata 来作图，还需要一样工具：生成器。</p><p>SVG 有一个元素，叫做路径<path>，是 SVG 中功能最强的元素，它可以表示其它任意的图形。顾名思义，路径元素就是通过定义一个段“路径”，来绘制出各种图形。但是，路径是很难计算的，通过布局转换后的数据 piedata 仍然很难手动计算得到路径值。为我们完成这项任务的，就是生成器。</path></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ourd3js.com/wordpress/" target="_blank" rel="noopener">http://www.ourd3js.com/wordpress/</a></p>]]></content>
      <categories>
        <category>笔记</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>D3</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5和ES6</title>
    <url>/2018/03/26/ES5%E5%92%8CES6/</url>
    <content><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数没有自己的this值，其this值是通过继承其它传入对象而获得的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//es5</span></span><br><span class="line">button.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line">button.onclick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">123</span>)&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="es5-Array方法"><a href="#es5-Array方法" class="headerlink" title="es5 Array方法"></a>es5 Array方法</h3><p>增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">12</span>,<span class="number">31</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>];<span class="comment">//全局的数组</span></span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//es5,相当于for()</span></span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> ret = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//es5,原数组映射新数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> filter = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//es5,过滤，返回过滤后的新数组</span></span><br><span class="line">	<span class="keyword">return</span> item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> some = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//es5,某些值合乎条件，some只要有true即返回不再执行了，返回Boolean值</span></span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">20</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>array.every(callback,[ thisObject])：返回Boolean值,需要每一个值都满足条件才返回true。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">12</span>,<span class="string">'3'</span>));</span><br><span class="line"><span class="comment">//从4号位开始搜索12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">//从后往前搜索，索引值小于3开始</span></span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>array.reduce(callback,[initialValue])：callback函数接受4个参数：之前值、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。若指定，则当作最初使用的previous值；如果缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位，相比有initialValue值少一次迭代。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> reduce = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous,current,index,array</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> previous + current;</span><br><span class="line">&#125;);<span class="comment">//es5,类似于迭代</span></span><br></pre></td></tr></table></figure><p></p><h3 id="es6特性"><a href="#es6特性" class="headerlink" title="es6特性"></a>es6特性</h3><h4 id="块级作用域-关键字let-常量const。"><a href="#块级作用域-关键字let-常量const。" class="headerlink" title="块级作用域 关键字let, 常量const。"></a>块级作用域 关键字let, 常量const。</h4><p>和var的区别：let和const不允许在相同作用域内，重复声明同一个变量。let不像var那样，会发生“变量提升”现象。const声明常量，声明之后常量的值不会改变。</p><p>let和const声明的变量内存空间不挂在于window上，而var声明的变量是挂载到window上。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a:<span class="number">10</span>,</span><br><span class="line">  b:<span class="number">20</span>,</span><br><span class="line">  func:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">100</span>;<span class="comment">//window</span></span><br><span class="line">    <span class="keyword">this</span>.b = <span class="number">200</span>;<span class="comment">//window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.func();</span><br><span class="line"><span class="built_in">console</span>.log(a,obj.a);<span class="comment">//100 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b,obj.b);<span class="comment">//2 20</span></span><br></pre></td></tr></table></figure><p></p><h4 id="赋值解构"><a href="#赋值解构" class="headerlink" title="赋值解构"></a>赋值解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">"Bob"</span>, <span class="attr">id</span>: <span class="string">"123"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: n, <span class="attr">id</span>: i &#125; = person;</span><br><span class="line"><span class="comment">// 相当于 n = "Bob", i = "123"</span></span><br></pre></td></tr></table></figure><h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h4><pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">`&lt;p&gt;</span></span><br><span class="line"><span class="string">  hello world</span></span><br><span class="line"><span class="string">&lt;/p&gt;`</span></span><br></pre></td></tr></table></figure>
</code></pre><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  <span class="comment">//es6,与forEach()不一样，用于遍历数据，它支持break，continue和return</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增类型"><a href="#新增类型" class="headerlink" title="新增类型"></a>新增类型</h4><p>四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。</p><p>Map<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//es6,map对象，map里面的数据由键值对组成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新的key-value</span></span><br><span class="line">map.set(<span class="string">'a'</span>, <span class="number">6</span>);</span><br><span class="line">map.set(<span class="string">'b'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否存在key</span></span><br><span class="line">map.has(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">map.get(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">map.delete(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key+<span class="string">':'</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Set：似于数组，但它的一大特性就是所有元素都是唯一的，没有重复。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> sets = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>]);<span class="comment">//es6,一个set对象使用于排除重复项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> w <span class="keyword">of</span> sets)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//向Set中添加元素。</span></span><br><span class="line"> sets.add(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从Set中删除元素</span></span><br><span class="line"> sets.delete(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断某元素是否存在</span></span><br><span class="line"> sets.has(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//清除所有</span></span><br><span class="line"> sets.clear()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//转为数组</span></span><br><span class="line"> <span class="keyword">var</span> array =  <span class="built_in">Array</span>.from(sets);</span><br></pre></td></tr></table></figure><p></p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//生成器函数以function*开头，yield在其中是关键字，可以暂时中断生成器</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">quips</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"i hope you are enjoying the blog posts"</span>;</span><br><span class="line">   <span class="keyword">if</span> (name.startsWith(<span class="string">"X"</span>)) &#123;</span><br><span class="line">     <span class="keyword">yield</span> <span class="string">"it's cool how your name starts with X, "</span> + name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">"see you later!"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//每当调用生成器对象的.next()方法时，函数恢复运行直至遇到下一个yield表达式，其作用是用于迭代</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> iter = quips(<span class="string">'jore'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iter.next())</span><br><span class="line"><span class="built_in">console</span>.log(iter.next())</span><br><span class="line"><span class="built_in">console</span>.log(iter.next())</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br></pre></td></tr></table></figure><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(start,stop)&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = start;</span><br><span class="line">		<span class="keyword">this</span>.stop = stop;</span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	next()&#123;</span><br><span class="line">		<span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">		<span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.stop)&#123;</span><br><span class="line">			<span class="keyword">this</span>.value++;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:value&#125;;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成器生成迭代器"><a href="#生成器生成迭代器" class="headerlink" title="生成器生成迭代器"></a>生成器生成迭代器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//one,通过使用[Symbol.iterator]()和.next()来进行创建迭代器</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start,stop</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start,stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//two,生成器生成迭代器</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start,stop</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =start;i&lt;stop;i++)</span><br><span class="line">		<span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  alert(<span class="string">"Ding! at floor #"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剩余参数与默认值"><a href="#剩余参数与默认值" class="headerlink" title="剩余参数与默认值"></a>剩余参数与默认值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">containAll</span>(<span class="params">value=<span class="string">"cat"</span>,...needles</span>)</span>&#123;<span class="comment">//es6,剩余参数与默认值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">of</span> needles)&#123;</span><br><span class="line">		<span class="keyword">if</span>(value.indexOf(n)===<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/fuheng01/articles/JS.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuheng01/articles/JS.html</a></p><p><a href="https://blog.csdn.net/hbts_901111zb/article/details/79242091" target="_blank" rel="noopener">https://blog.csdn.net/hbts_901111zb&#x2F;article&#x2F;details&#x2F;79242091</a></p>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>D3学习记录2</title>
    <url>/2018/03/06/D3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<p>继续，比例尺和坐标轴。</p><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>本文绘制一个横向的柱形图。只绘制矩形，不绘制文字和坐标轴。</p><a id="more"></a><p>在 SVG 中，矩形的元素标签是 rect。例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 rect 里没有矩形的属性。矩形的属性，常用的有四个：</p><ul><li>x：矩形左上角的 x 坐标</li><li>y：矩形左上角的 y 坐标</li><li>width：矩形的宽度</li><li>height：矩形的高度</li></ul><p>要注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。<br>现在给出一组数据，要对此进行可视化。数据如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [ <span class="number">250</span> , <span class="number">210</span> , <span class="number">170</span> , <span class="number">130</span> , <span class="number">90</span> ];  <span class="comment">//数据（表示矩形的宽度</span></span><br></pre></td></tr></table></figure><p>为简单起见，我们直接用数值的大小来表示矩形的像素宽度（后面会说到这不是一种好方法）。然后，添加以下代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rectHeight = 25;   //每个矩形所占的像素高度(包括空白)</span><br><span class="line">svg.selectAll(&quot;rect&quot;)</span><br><span class="line">    .data(dataset)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(&quot;rect&quot;)</span><br><span class="line">    .attr(&quot;x&quot;,20)</span><br><span class="line">    .attr(&quot;y&quot;,function(d,i)&#123;</span><br><span class="line">         return i * rectHeight;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(&quot;width&quot;,function(d)&#123;</span><br><span class="line">         return d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(&quot;height&quot;,rectHeight-2)</span><br><span class="line">    .attr(&quot;fill&quot;,&quot;steelblue&quot;);</span><br></pre></td></tr></table></figure><p>这段代码添加了与 dataset 数组的长度相同数量的矩形，所使用的语句是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.selectAll(<span class="string">"rect"</span>)   <span class="comment">//选择svg内所有的矩形</span></span><br><span class="line">    .data(dataset)  <span class="comment">//绑定数组</span></span><br><span class="line">    .enter()        <span class="comment">//指定选择集的enter部分</span></span><br><span class="line">    .append(<span class="string">"rect"</span>) <span class="comment">//添加足够数量的矩形元素</span></span><br></pre></td></tr></table></figure><p>当有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。</p><p>添加了元素之后，就需要分别给各元素的属性赋值。在这里用到了 function(d, i)，前面已经讲过，d 代表与当前元素绑定的数据，i 代表索引号。给属性赋值的时候，是需要用到被绑定的数据，以及索引号的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.attr(<span class="string">"fill"</span>,<span class="string">"steelblue"</span>);<span class="comment">//给矩形元素设置颜色</span></span><br></pre></td></tr></table></figure><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><blockquote><p>将某一区域的值映射到另一区域，其大小关系不变。</p></blockquote><p>D3 中的比例尺，也有定义域和值域，分别被称为 domain 和 range。开发者需要指定 domain 和 range 的范围，如此即可得到一个计算关系。</p><h4 id="线性比例尺"><a href="#线性比例尺" class="headerlink" title="线性比例尺"></a>线性比例尺</h4><p>线性比例尺，能将一个连续的区间，映射到另一区间。要解决柱形图宽度的问题，就需要线性比例尺。</p><p>假设有以下数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">0.9</span>, <span class="number">1.5</span>, <span class="number">3.3</span>];</span><br></pre></td></tr></table></figure><p>要求将 dataset 中最小的值，映射成 0；将最大的值，映射成 300。<br>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> min = d3.min(dataset);</span><br><span class="line"><span class="keyword">var</span> max = d3.max(dataset);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> linear = d3.scale.linear()</span><br><span class="line">        .domain([min, max])</span><br><span class="line">        .range([<span class="number">0</span>, <span class="number">300</span>]);</span><br><span class="line"> </span><br><span class="line">linear(<span class="number">0.9</span>);    <span class="comment">//返回 0</span></span><br><span class="line">linear(<span class="number">2.3</span>);    <span class="comment">//返回 175</span></span><br><span class="line">linear(<span class="number">3.3</span>);    <span class="comment">//返回 300</span></span><br></pre></td></tr></table></figure><p>其中，<font color="#63ca87">d3.scale.linear()</font> 返回一个线性比例尺。domain() 和 range() 分别设定比例尺的定义域和值域。在这里还用到了两个函数，它们经常与比例尺一起出现：</p><ul><li>d3.max()</li><li>d3.min()</li></ul><p>这两个函数能够求数组的最大值和最小值，是 D3 提供的。按照以上代码，比例尺的定义域 domain 为：[0.9, 3.3]，比例尺的值域 range 为：[0, 300]。因此，当输入 0.9 时，返回 0；当输入 3.3 时，返回 300。</p><p>d3.scale.linear() 的返回值，是可以当做函数来使用的。因此，才有这样的用法：linear(0.9)。</p><h4 id="序数比例尺"><a href="#序数比例尺" class="headerlink" title="序数比例尺"></a>序数比例尺</h4><p>有时候，定义域和值域不一定是连续的。例如，有两个数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>];</span><br></pre></td></tr></table></figure><p>我们希望 0 对应颜色 red，1 对应 blue，依次类推。<br>但是，这些值都是离散的，线性比例尺不适合，需要用到序数比例尺。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ordinal = d3.scale.ordinal()</span><br><span class="line">        .domain(index)</span><br><span class="line">        .range(color);</span><br><span class="line"> </span><br><span class="line">ordinal(<span class="number">0</span>); <span class="comment">//返回 red</span></span><br><span class="line">ordinal(<span class="number">2</span>); <span class="comment">//返回 green</span></span><br><span class="line">ordinal(<span class="number">4</span>); <span class="comment">//返回 black</span></span><br></pre></td></tr></table></figure><h4 id="给柱形图添加比例尺"><a href="#给柱形图添加比例尺" class="headerlink" title="给柱形图添加比例尺"></a>给柱形图添加比例尺</h4><p>修改一下数组，再定义一个线性比例尺。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [ <span class="number">2.5</span> , <span class="number">2.1</span> , <span class="number">1.7</span> , <span class="number">1.3</span> , <span class="number">0.9</span> ];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> linear = d3.scale.linear()</span><br><span class="line">        .domain([<span class="number">0</span>, d3.max(dataset)])</span><br><span class="line">        .range([<span class="number">0</span>, <span class="number">250</span>]);</span><br></pre></td></tr></table></figure><p>按照上一章的方法添加矩形，在给矩形设置宽度的时候，应用比例尺。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rectHeight = <span class="number">25</span>;   <span class="comment">//每个矩形所占的像素高度(包括空白)</span></span><br><span class="line"> </span><br><span class="line">svg.selectAll(<span class="string">"rect"</span>)</span><br><span class="line">    .data(dataset)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">"rect"</span>)</span><br><span class="line">    .attr(<span class="string">"x"</span>,<span class="number">20</span>)</span><br><span class="line">    .attr(<span class="string">"y"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> i * rectHeight;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"width"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> linear(d);   <span class="comment">//在这里用比例尺</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"height"</span>,rectHeight<span class="number">-2</span>)</span><br><span class="line">    .attr(<span class="string">"fill"</span>,<span class="string">"steelblue"</span>);</span><br></pre></td></tr></table></figure><p>如此一来，所有的数值，都按照同一个线性比例尺的关系来计算宽度，因此数值之间的大小关系不变。</p><h3 id="坐标轴的构成"><a href="#坐标轴的构成" class="headerlink" title="坐标轴的构成"></a>坐标轴的构成</h3><p>在 SVG 画布的预定义元素里，有六种基本图形：</p><ul><li>矩形<rect></rect></li><li>圆形<circle></circle></li><li>椭圆<ellipse></ellipse></li><li>线段<line></line></li><li>折线<polyline></polyline></li><li>多边形<polygon></polygon></li></ul><p>另外，还有一种比较特殊，也是功能最强的元素：</p><ul><li>路径<path></path></li></ul><p>画布中的所有图形，都是由以上七种元素组成。<br>这里面没有坐标轴<axis>这种元素。因为d3不可能为每一种图形都配备一个单独的元素，那样 SVG 就会过于庞大。</axis></p><p>我们需要用其他元素来组合成坐标轴，最终使其变为类似以下的形式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 第一个刻度 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span>   <span class="comment">&lt;!-- 第一个刻度的直线 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span>   <span class="comment">&lt;!-- 第一个刻度的文字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 第二个刻度 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span>   <span class="comment">&lt;!-- 第二个刻度的直线 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span>   <span class="comment">&lt;!-- 第二个刻度的文字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!-- 坐标轴的轴线 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分组元素<g>，是 SVG 画布中的元素，意思是 group。此元素是将其他元素进行组合的容器，在这里是用于将坐标轴的其他元素分组存放。</g></p><p>如果需要手动添加这些元素就太麻烦了，为此，D3 提供了一个组件：d3.svg.axis()。</p><h4 id="定义坐标轴"><a href="#定义坐标轴" class="headerlink" title="定义坐标轴"></a>定义坐标轴</h4><p>要生成坐标轴，需要用到比例尺，它们二者经常是一起使用的。下面，在上一章的数据和比例尺的基础上，添加一个坐标轴的组件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="keyword">var</span> dataset = [ <span class="number">2.5</span> , <span class="number">2.1</span> , <span class="number">1.7</span> , <span class="number">1.3</span> , <span class="number">0.9</span> ];</span><br><span class="line"><span class="comment">//定义比例尺,其中使用了数组 dataset</span></span><br><span class="line"><span class="keyword">var</span> linear = d3.scale.linear()</span><br><span class="line">      .domain([<span class="number">0</span>, d3.max(dataset)])</span><br><span class="line">      .range([<span class="number">0</span>, <span class="number">250</span>]);</span><br><span class="line"><span class="comment">//定义坐标轴，其中使用了线性比例尺 linear。</span></span><br><span class="line"><span class="keyword">var</span> axis = d3.svg.axis() <span class="comment">//D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素</span></span><br><span class="line">     .scale(linear)      <span class="comment">//指定比例尺</span></span><br><span class="line">     .orient(<span class="string">"bottom"</span>)   <span class="comment">//指定刻度的方向,bottom 表示在坐标轴的下方显示。</span></span><br><span class="line">     .ticks(<span class="number">7</span>);          <span class="comment">//指定刻度的数量</span></span><br></pre></td></tr></table></figure><h4 id="在-SVG-中添加坐标轴"><a href="#在-SVG-中添加坐标轴" class="headerlink" title="在 SVG 中添加坐标轴"></a>在 SVG 中添加坐标轴</h4><p>定义了坐标轴之后，只需要在 SVG 中添加一个分组元素<g>，再将坐标轴的其他元素添加到这个<g>里即可。代码如下：</g></g></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.append(<span class="string">"g"</span>).call(axis);</span><br><span class="line"><span class="comment">// call() 函数，其参数是前面定义的坐标轴 axis</span></span><br></pre></td></tr></table></figure><p>在 D3 中，call() 的参数是一个函数。调用之后，将当前的选择集作为参数传递给此函数。也就是说，以下两段代码是相等的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">selection</span>) </span>&#123;</span><br><span class="line">  selection</span><br><span class="line">      .attr(<span class="string">"name1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">      .attr(<span class="string">"name2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(d3.selectAll(<span class="string">"div"</span>))</span><br><span class="line"><span class="comment">//和</span></span><br><span class="line">d3.selectAll(<span class="string">"div"</span>).call(foo);</span><br></pre></td></tr></table></figure><h4 id="设定坐标轴的样式和位置"><a href="#设定坐标轴的样式和位置" class="headerlink" title="设定坐标轴的样式和位置"></a>设定坐标轴的样式和位置</h4><p>默认的坐标轴样式不太美观，下面提供一个常见的样式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.axis path,</span><br><span class="line">.axis line&#123;</span><br><span class="line">    fill: none;</span><br><span class="line">    stroke: black;</span><br><span class="line">    shape-rendering: crispEdges;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.axis text &#123;</span><br><span class="line">    font-family: sans-serif;</span><br><span class="line">    font-size: 11px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分别定义了类 axis 下的 path、line、text 元素的样式。接下来，只需要将坐标轴的类设定为 axis 即可。坐标轴的位置，可以通过 transform 属性来设定。</p><p>通常在添加元素的时候就一并设定，写成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.append(<span class="string">"g"</span>)</span><br><span class="line">  .attr(<span class="string">"class"</span>,<span class="string">"axis"</span>)</span><br><span class="line">  .attr(<span class="string">"transform"</span>,<span class="string">"translate(20,130)"</span>)</span><br><span class="line">  .call(axis);</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ourd3js.com/wordpress/" target="_blank" rel="noopener">http://www.ourd3js.com/wordpress/</a></p>]]></content>
      <categories>
        <category>笔记</category>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>D3</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter TextField属性详解</title>
    <url>/2019/10/22/Flutter-TextField%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="TextField和TextFormField的属性"><a href="#TextField和TextFormField的属性" class="headerlink" title="TextField和TextFormField的属性"></a>TextField和TextFormField的属性</h2><p>输入框是比较复杂的组件，文本输入是最常见的一种交互方式，应用的情况也比较多。在上一个项目中，关于输入框的组件处理了很多，所以觉得很有必要单独拎出来了解下。</p><a id="more"></a><p>以下是输入框的属性和方法：</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">decoration</td><td align="center">InputDecoration</td><td align="center">输入框的装饰器，设置内容或者装饰</td></tr><tr><td align="center">controller</td><td align="center">TextEditingController</td><td align="center">控制器，跟输入框的交互一般都通过该属性完成，如果不创建的话默认会自动创建</td></tr><tr><td align="center">focusNode</td><td align="center">FocusNode</td><td align="center">焦点控制</td></tr><tr><td align="center">keyboardType</td><td align="center">TextInputType</td><td align="center">设置输入类型(键盘类型)</td></tr><tr><td align="center">inputFormatters</td><td align="center">List<textinputformatter></textinputformatter></td><td align="center">限制输入文本的格式</td></tr><tr><td align="center">obscureText</td><td align="center">bool</td><td align="center">是否隐藏输入的文字</td></tr><tr><td align="center">textInputAction</td><td align="center">TextInputAction</td><td align="center">键盘事件类型</td></tr><tr><td align="center">textCapitalization</td><td align="center">TextCapitalization</td><td align="center">设置文本大写</td></tr><tr><td align="center">style</td><td align="center">TextStyle</td><td align="center">输入文本的样式</td></tr><tr><td align="center">textAlign</td><td align="center">TextAlign</td><td align="center">文本的对齐方式</td></tr><tr><td align="center">textDirection</td><td align="center">TextDirection</td><td align="center">文字的排列方向</td></tr><tr><td align="center">autofocus</td><td align="center">bool</td><td align="center">是否自动获取焦点</td></tr><tr><td align="center">autocorrect</td><td align="center">bool</td><td align="center">是否自动校验</td></tr><tr><td align="center">maxLines</td><td align="center">int</td><td align="center">最大行数</td></tr><tr><td align="center">maxLength</td><td align="center">int</td><td align="center">输入的最大字符个数</td></tr><tr><td align="center">maxLengthEnforced</td><td align="center">bool</td><td align="center">配合maxLength一起使用，在达到最大长度时是否阻止输入</td></tr><tr><td align="center">onEditingComplete</td><td align="center">VoidCallback</td><td align="center">点击键盘完成按钮时触发的回调，该回调没有参数，(){}</td></tr><tr><td align="center">onSubmitted</td><td align="center">VoidCallback</td><td align="center">点击键盘完成按钮时触发的回调，该回调有参数，参数即为当前输入框中的值。(v){}</td></tr><tr><td align="center">enabled</td><td align="center">bool</td><td align="center">输入框是否可用</td></tr><tr><td align="center">cursorWidth</td><td align="center">double</td><td align="center">光标的宽度</td></tr><tr><td align="center">cursorRadius</td><td align="center">Radius</td><td align="center">光标的圆角</td></tr><tr><td align="center">cursorColor</td><td align="center">Color</td><td align="center">光标的颜色</td></tr></tbody></table><h3 id="TextField-普通输入框"><a href="#TextField-普通输入框" class="headerlink" title="TextField(普通输入框)"></a>TextField(普通输入框)</h3><p>普通输入框指的是单独的输入框，没有在表单中的输入框。它和表单中的输入框TextFormField方法略有不同，TextFormField是在TextField的基础上扩展的。</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">onChanged</td><td align="center">VoidCallback</td><td align="center">用户输入时的回调(v){}</td></tr><tr><td align="center">onTap</td><td align="center">VoidCallback</td><td align="center">点击输入框时的回调</td></tr></tbody></table><h3 id="TextFormField-表单里的输入框"><a href="#TextFormField-表单里的输入框" class="headerlink" title="TextFormField(表单里的输入框)"></a>TextFormField(表单里的输入框)</h3><p>表单中的输入框最主要的特点就是提供了表单验证。</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">validator</td><td align="center">FormFieldValidator&lt;T&gt;</td><td align="center">表单验证器</td></tr><tr><td align="center">autovalidate</td><td align="center">bool</td><td align="center">自动验证值</td></tr><tr><td align="center">onSaved</td><td align="center">FormFieldSetter&lt;T&gt;</td><td align="center">表单保存的回调方法</td></tr><tr><td align="center">initalValue</td><td align="center">T</td><td align="center">表单字段初始值</td></tr></tbody></table><h3 id="InputDecoration"><a href="#InputDecoration" class="headerlink" title="InputDecoration"></a>InputDecoration</h3><p>TextField装饰器，可以理解成输入框的默认属性和一些样式定义，以下是它的构造方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputDecoration(&#123;</span><br><span class="line">    this.icon,    //位于装饰器外部和输入框前面的图片</span><br><span class="line">    this.labelText,  //用于描述输入框，当输入框获取焦点时默认会浮动到上方，</span><br><span class="line">    this.labelStyle,  // 控制labelText的样式,接收一个TextStyle类型的值</span><br><span class="line">    this.helperText, //辅助文本，位于输入框下方，如果errorText不为空的话，则helperText不会显示</span><br><span class="line">    this.helperStyle, //helperText的样式</span><br><span class="line">    this.hintText,  //提示文本，位于输入框内部</span><br><span class="line">    this.hintStyle, //hintText的样式</span><br><span class="line">    this.hintMaxLines, //提示信息最大行数</span><br><span class="line">    this.errorText,  //错误信息提示</span><br><span class="line">    this.errorStyle, //errorText的样式</span><br><span class="line">    this.errorMaxLines,   //errorText最大行数</span><br><span class="line">    this.hasFloatingPlaceholder = true,  //labelText是否浮动，默认为true，修改为false则labelText在输入框获取焦点时不会浮动且不显示</span><br><span class="line">    this.isDense,   //改变输入框是否为密集型，默认为false，修改为true时，图标及间距会变小</span><br><span class="line">    this.contentPadding, //内间距</span><br><span class="line">    this.prefixIcon,  //位于输入框内部起始位置的图标。</span><br><span class="line">    this.prefix,   //预先填充的Widget,跟prefixText同时只能出现一个</span><br><span class="line">    this.prefixText,  //预填充的文本，例如手机号前面预先加上区号等</span><br><span class="line">    this.prefixStyle,  //prefixText的样式</span><br><span class="line">    this.suffixIcon, //位于输入框后面的icon</span><br><span class="line">    this.suffix,  //位于输入框尾部的控件，同样的不能和suffixText同时使用</span><br><span class="line">    this.suffixText,//位于尾部的填充文字</span><br><span class="line">    this.suffixStyle,  //suffixText的样式</span><br><span class="line">    this.counter,//位于输入框右下方的小控件，不能和counterText同时使用</span><br><span class="line">    this.counterText,//位于右下方显示的文本，常用于显示输入的字符数量</span><br><span class="line">    this.counterStyle, //counterText的样式</span><br><span class="line">    this.filled,  //如果为true，则输入使用fillColor指定的颜色填充</span><br><span class="line">    this.fillColor,  //相当于输入框的背景颜色</span><br><span class="line">    this.errorBorder,   //errorText不为空，输入框没有焦点时要显示的边框</span><br><span class="line">    this.focusedBorder,  //输入框有焦点时的边框,如果errorText不为空的话，该属性无效</span><br><span class="line">    this.focusedErrorBorder,  //errorText不为空时，输入框有焦点时的边框</span><br><span class="line">    this.disabledBorder,  //输入框禁用时显示的边框，如果errorText不为空的话，该属性无效</span><br><span class="line">    this.enabledBorder,  //输入框可用时显示的边框，如果errorText不为空的话，该属性无效</span><br><span class="line">    this.border, //正常情况下的border</span><br><span class="line">    this.enabled = true,  //输入框是否可用</span><br><span class="line">    this.semanticCounterText,</span><br><span class="line">    this.alignLabelWithHint,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="inputFormatters"><a href="#inputFormatters" class="headerlink" title="inputFormatters"></a>inputFormatters</h3><p>用于限制输入的内容。</p><ul><li>WhitelistingTextInputFormatter 白名单校验，也就是只允许输入符合规则的字符</li><li>BlacklistingTextInputFormatter 黑名单校验，除了规定的字符其他的都可以输入</li><li>LengthLimitingTextInputFormatter 长度限制，跟maxLength作用类似</li></ul><p>例如：只允许输入数字，并且不超过6个字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inputFormatters: [</span><br><span class="line">      WhitelistingTextInputFormatter.digitsOnly,</span><br><span class="line">      LengthLimitingTextInputFormatter(6)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="文本监听"><a href="#文本监听" class="headerlink" title="文本监听"></a>文本监听</h3><p>新建一个简单的输入框，并实现文本监听，栗子1：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> _inputText = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//控制器</span></span><br><span class="line">TextEditingController _controller = <span class="keyword">new</span> TextEditingController.fromValue(</span><br><span class="line">  TextEditingValue(</span><br><span class="line">    text: _inputText,</span><br><span class="line">    selection: <span class="keyword">new</span> TextSelection.fromPosition(</span><br><span class="line">      TextPosition(</span><br><span class="line">          affinity: TextAffinity.downstream, offset:_inputText.length),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"><span class="comment">//输入框</span></span><br><span class="line">TextField(</span><br><span class="line">  controller:_controller,</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.person),</span><br><span class="line">    labelText:<span class="string">'用户名'</span></span><br><span class="line">  ),</span><br><span class="line">  onChanged: (v)&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _inputText = v;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当使用TextFormField时没有onChanged，只能手动实现监听，栗子2：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> _inputText = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//控制器</span></span><br><span class="line">TextEditingController _controller = <span class="keyword">new</span> TextEditingController.fromValue(</span><br><span class="line">  TextEditingValue(</span><br><span class="line">    text: _inputText,</span><br><span class="line">    selection: <span class="keyword">new</span> TextSelection.fromPosition(</span><br><span class="line">      TextPosition(</span><br><span class="line">          affinity: TextAffinity.downstream, offset:_inputText.length),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"><span class="comment">//监听值的变化</span></span><br><span class="line"><span class="keyword">void</span> onChange() &#123;</span><br><span class="line">  <span class="built_in">String</span> v = _textController.text;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _inputText = v;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">_controller.addListener(onChange);</span><br><span class="line"><span class="comment">//输入框</span></span><br><span class="line">TextFormField(</span><br><span class="line">  controller:_controller,</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.person),</span><br><span class="line">    labelText:<span class="string">'用户名'</span></span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="实现文本清除按钮"><a href="#实现文本清除按钮" class="headerlink" title="实现文本清除按钮"></a>实现文本清除按钮</h3><p>在输入框有内容时显示清除按钮，在输入框内容为空时隐藏清除按钮，栗子3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TextEditingController _controller = new TextEditingController();</span><br><span class="line">//带清除的输入框</span><br><span class="line">TextField(</span><br><span class="line">  controller:_controller,</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.person),</span><br><span class="line">    suffixIcon:_controller.text.length &gt; 0</span><br><span class="line">              ? IconButton(</span><br><span class="line">                  icon: Icon(</span><br><span class="line">                    Icons.cancel,</span><br><span class="line">                    size:20.0,</span><br><span class="line">                    color: Colors.grey,</span><br><span class="line">                  ),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    WidgetsBinding.instance.addPostFrameCallback((_) =&gt; _controller.clear());</span><br><span class="line">                  &#125;,</span><br><span class="line">                ) : Text(&quot;&quot;),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/88204031" target="_blank" rel="noopener">Flutter文本输入框TextField属性</a></p>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件模型</title>
    <url>/2018/03/01/JS%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>HTML 事件可以是浏览器行为，也可以是用户行为。<br>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><a id="more"></a><h3 id="javascript中有两种事件模型：DOM0，DOM2。"><a href="#javascript中有两种事件模型：DOM0，DOM2。" class="headerlink" title="javascript中有两种事件模型：DOM0，DOM2。"></a>javascript中有两种事件模型：DOM0，DOM2。</h3><ol><li>dom0中，一个dom对象只能注册一个同类型的函数，因为注册多个同类型的函数的话，就会发生覆盖，之前注册的函数就会无效。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">'click'</span>);</span><br><span class="line">click.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'you click the first function'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">click.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'you click the second function'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解除事件</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'click'</span>_).onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>在DOM2级中使用addEventListener和removeEventListener来注册和解除事件（IE8及之前版本不支持）。</li></ol><p>这种函数较之前的方法好处是一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addEventListener('事件名称','事件回调','捕获/冒泡')</span></span><br><span class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">'inner'</span>);</span><br><span class="line">click.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'click one'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">click.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'click two'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>addEventListenr的第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表捕获还是冒泡，true代表捕获事件，false代表冒泡事件。</p><ol start="3"><li>正常的情况下，我们在不添加stopPropagation函数时，首先应该执行inner，然后执行outer，但是当我们在inner的事件函数中添加了stopPropagation函数之后，执行完inner的事件函数之后，就不会在执行outer的事件函数了，也可以理解为事件冒泡到inner之后就消失了，因此也就不会在执行接下来的事件函数了。<br>由于事件捕获阶段没有可以阻止事件的函数，所以一般都是设置为事件冒泡。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">'inner'</span>);</span><br><span class="line"><span class="keyword">var</span> clickouter = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);</span><br><span class="line"></span><br><span class="line">click.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'inner show'</span>);</span><br><span class="line">	 event.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">clickouter.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'outer show'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程可称为DOM事件流。</p><p>DOM标准同时支持两种事件模型，即捕获型事件与冒泡型事件，但是，捕获型事件先发生。两种事件流都会触发DOM中的所有对象，从document对象开始，也在document对象结束（大部分兼容标准的浏览器会继续将事件是捕捉&#x2F;冒泡延续到window对象）。</p><p>例如：标准的事件转送模式。</p><ol><li>在事件捕捉（Capturing）阶段，事件将沿着DOM树向下转送，目标节点的每一个祖先节点，直至目标节点。例如，若用户单击了一个超链接，则该单击事件将从document节点转送到html元素，body元素以及包含该链接的p元素。</li></ol><p>在此过程中，浏览器都会检测针对该事件的捕捉事件监听器，并且运行这件事件监听器。</p><ol start="2"><li><p>在目标（target）阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行该事件监听器。目标节点就是触发事件的DOM节点。例如，如果用户单击一个超链接，那么该链接就是目标节点（此时的目标节点实际上是超链接内的文本节点）。</p></li><li><p>在冒泡（Bubbling）阶段，事件将沿着DOM树向上转送，再次逐个访问目标元素的祖先节点到document节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。</p></li></ol><blockquote><p>所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段。例如，让元素获得输入焦点的focus事件以及失去输入焦点的blur事件就都不会冒泡。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/Leesoo/p/6892204.html" target="_blank" rel="noopener">https://www.cnblogs.com/Leesoo/p/6892204.html</a></p><p><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a></p>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter布局</title>
    <url>/2019/10/22/Flutter%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="布局组件"><a href="#布局组件" class="headerlink" title="布局组件"></a>布局组件</h2><p>布局类组件就是指直接或间接继承(包含)MultiChildRenderObjectWidget的Widget，它们一般都会有一个children属性用于接收子Widget。</p><h3 id="线性布局（Row、Column）"><a href="#线性布局（Row、Column）" class="headerlink" title="线性布局（Row、Column）"></a>线性布局（Row、Column）</h3><p>线性布局，即指沿水平或垂直方向排布子组件，将子组件排成一行或一列。</p><a id="more"></a><h4 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h4><p>Row可以在水平方向排列其子widget。Row默认只有一行，如果超出屏幕不会折行，会报溢出错误。Row以及Column都是Flex的子类，它们的具体实现也都是由Flex完成，只是参数不同。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mainAxisAlignment</td><td align="center">MainAxisAlignment</td><td align="center">MainAxisAlignment.start</td><td align="center">水平方向的对齐方式</td></tr><tr><td align="center">crossAxisAlignment</td><td align="center">CrossAxisAlignment</td><td align="center"></td><td align="center">纵轴方向的对齐方式</td></tr><tr><td align="center">mainAxisSize</td><td align="center">MainAxisSize</td><td align="center">MainAxisSize.max</td><td align="center">Row在主轴(水平)方向占用的空间</td></tr><tr><td align="center">textDirection</td><td align="center">TextDirection</td><td align="center"></td><td align="center">水平方向子组件的布局顺序</td></tr><tr><td align="center">verticalDirection</td><td align="center">VerticalDirection</td><td align="center">VerticalDirection.down</td><td align="center">纵轴（垂直）方向的布局顺序</td></tr><tr><td align="center">children</td><td align="center">List&lt;Widget&gt;</td><td align="center"></td><td align="center">子组件数组</td></tr><tr><td align="center">MainAxisAlignment：</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>center：将children放置在主轴的中心；</li><li>end：将children放置在主轴的末尾；</li><li>spaceAround：将主轴方向上的空白区域均分，使得children之间的空白区域相等，但是首尾child的空白区域为1&#x2F;2；</li><li>spaceBetween：将主轴方向上的空白区域均分，使得children之间的空白区域相等，首尾child都靠近首尾，没有间隙；</li><li>spaceEvenly：将主轴方向上的空白区域均分，使得children之间的空白区域相等，包括首尾child；</li><li>start：将children放置在主轴的起点；</li></ul><p>CrossAxisAlignment：</p><ul><li>baseline：在交叉轴方向，使得children的baseline对齐；</li><li>center：children在交叉轴上居中展示；</li><li>end：children在交叉轴上末尾展示；</li><li>start：children在交叉轴上起点处展示；</li><li>stretch：让children填满交叉轴方向；</li></ul><h4 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h4><p>Column可以在垂直方向排列其子组件，因此和Row的主轴正好相反。</p><h3 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h3><p>弹性布局允许子组件按照一定比例来分配父容器空间。</p><h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><p>其属性和Row，Cloumn的属性差不多。<br>特有属性：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th>说明</th></tr></thead><tbody><tr><td align="center">direction</td><td align="center">Axis</td><td>必须项，弹性布局的方向, Row默认为水平方向(Axis.horizontal)，默认为垂直方向(Axis.vertical)</td></tr></tbody></table><h4 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h4><p>可以按比例“扩伸” Row、Column和Flex子组件所占用的空间。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">flex</td><td align="center">number</td><td align="center">flex参数为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间</td></tr><tr><td align="center">child</td><td align="center">Widget</td><td align="center">需要分配的子组件</td></tr></tbody></table><h3 id="流式布局（Warp、Flow）"><a href="#流式布局（Warp、Flow）" class="headerlink" title="流式布局（Warp、Flow）"></a>流式布局（Warp、Flow）</h3><p>超出屏幕显示范围会自动折行的布局。</p><h4 id="Warp"><a href="#Warp" class="headerlink" title="Warp"></a>Warp</h4><p>特有属性：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">spacing</td><td align="center">MainAxisAlignment</td><td align="center">主轴方向子widget的间距</td></tr><tr><td align="center">runSpacing</td><td align="center">CrossAxisAlignment</td><td align="center">纵轴方向的间距</td></tr><tr><td align="center">runAlignment</td><td align="center">MainAxisSize</td><td align="center">纵轴方向的对齐方式</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(</span><br><span class="line">  spacing: <span class="number">8.0</span>, <span class="comment">// 主轴(水平)方向间距</span></span><br><span class="line">  runSpacing: <span class="number">4.0</span>, <span class="comment">// 纵轴（垂直）方向间距</span></span><br><span class="line">  alignment: WrapAlignment.center, <span class="comment">//沿主轴方向居中</span></span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="keyword">new</span> Chip(</span><br><span class="line">      avatar: <span class="keyword">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">'A'</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> Text(<span class="string">'Hamilton'</span>),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> Chip(</span><br><span class="line">      avatar: <span class="keyword">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">'M'</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> Text(<span class="string">'Lafayette'</span>),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> Chip(</span><br><span class="line">      avatar: <span class="keyword">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">'H'</span>)),</span><br><span class="line">      label: <span class="keyword">new</span> Text(<span class="string">'Mulligan'</span>),</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h4><p>主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。缺点是使用复杂并且不能自适应子组件大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。</p><h3 id="层叠布局（Stack、Positioned）"><a href="#层叠布局（Stack、Positioned）" class="headerlink" title="层叠布局（Stack、Positioned）"></a>层叠布局（Stack、Positioned）</h3><p>层叠布局和Web中的绝对定位相似，子组件可以根据距父容器四个角的位置来确定自身的位置。绝对定位允许子组件堆叠起来。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">alignment</td><td align="center">AlignmentDirectional</td><td align="center">AlignmentDirectional.topStart</td><td align="center">如何去对齐没有定位（没有使用Positioned）或部分定位的子组件</td></tr><tr><td align="center">fit</td><td align="center">StackFit</td><td align="center">StackFit.loose</td><td align="center">确定没有定位的子组件如何去适应Stack的大小</td></tr><tr><td align="center">textDirection</td><td align="center">TextDirection</td><td align="center">TextDirection.ltr</td><td align="center">用于确定alignment对齐的参考系</td></tr><tr><td align="center">overflow</td><td align="center">Overflow</td><td align="center">Overflow.clip</td><td align="center">如何显示超出Stack显示空间的子组件</td></tr><tr><td align="center">children</td><td align="center">List&lt;Widget&gt;</td><td align="center"></td><td align="center">子组件数组</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">    alignment:Alignment.center ,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Container(child: Text(<span class="string">"Hello world"</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">        color: Colors.red,</span><br><span class="line">      ),</span><br><span class="line">      Positioned(</span><br><span class="line">        left: <span class="number">18.0</span>,</span><br><span class="line">        child: Text(<span class="string">"I am Jack"</span>),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><h4 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h4><p>属性： left, right, top, bottom, width, height, child。示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Positioned(</span><br><span class="line">       top: <span class="number">18.0</span>,</span><br><span class="line">       child: Text(<span class="string">"Your friend"</span>),</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><h3 id="对齐（Align）"><a href="#对齐（Align）" class="headerlink" title="对齐（Align）"></a>对齐（Align）</h3><p>Align 组件可以调整子组件的位置，并且可以根据子组件的宽高来确定自身的的宽高。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">alignment</td><td align="center">Alignment</td><td align="center">表示子组件在父组件中的起始位置</td></tr><tr><td align="center">widthFactor</td><td align="center">number</td><td align="center">组件本身的宽</td></tr><tr><td align="center">heightFactor</td><td align="center">number</td><td align="center">组件本身的高</td></tr><tr><td align="center">child</td><td align="center"></td><td align="center">子组件</td></tr><tr><td align="center">示例：</td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Align(</span><br><span class="line">  widthFactor: <span class="number">2</span>,</span><br><span class="line">  heightFactor: <span class="number">2</span>,</span><br><span class="line">  alignment: Alignment.topRight,</span><br><span class="line">  child: FlutterLogo(</span><br><span class="line">    size: <span class="number">60</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.flutterchina.club/chapter4/wrap_and_flow.html" target="_blank" rel="noopener">《Flutter实战》</a></p><p><a href="https://juejin.im/post/5b623d8c5188257f0b583c77" target="_blank" rel="noopener">Flutter 布局（七）- Row、Column详解</a></p>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>JS基础</title>
    <url>/2018/03/08/JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型：Number、String、Boolean、Null、Undefined、BigInt、Symbol</p><p>引用数据类型：Object、Array、Function</p><p>基本数据类型和引用数据类型它们在内存中的存储方式不同。 基本类型值是指简单的数据段，存储在栈中，按值访问。引用类型的值是保存在内存中的对象，存储在堆内存中，不能直接访问内存中的位置，实际操作对象时时操作对象的引用，因此是按引用访问的。</p><a id="more"></a><p>引用类型可以为其添加属性和方法。</p><blockquote><p>访问变量有按值和按引用两种方式，而参数只能按值传递。在向参数传递引用类型的值时，会把这个值内存中的地址复制给一个局部变量。</p></blockquote><p>所有对象都有valueOf(),toString(),toLocaleString()方法。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><blockquote><p>Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。 数据的创建方法Symbol()，因为它的构造函数不够完整，所以不能使用new Symbol()创建数据。由于Symbol()创建数据具有唯一性，所以 Symbol() !&#x3D;&#x3D; Symbol(), 同时使用Symbol数据作为key不能使用for获取到这个key，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。</p></blockquote><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><blockquote><p>BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。</p></blockquote><blockquote><p>使用方法：</p><ul><li>整数末尾直接+n：647326483767797n</li><li>调用BigInt()构造函数：BigInt(“647326483767797”)</li></ul></blockquote><h3 id="break和countinue"><a href="#break和countinue" class="headerlink" title="break和countinue"></a>break和countinue</h3><p>break会立即退出循环，continue会退出该循环，然后从该循环继续往下执行。</p><h3 id="number类型的方法"><a href="#number类型的方法" class="headerlink" title="number类型的方法"></a>number类型的方法</h3><p>将数值格式化为字符串：</p><ul><li>toFixed()：按照指定的小数位返回数值的字符串表示；</li><li>toExponential()：返回以指数表示法表示的数值的字符串；</li><li>toPrecision()：根据要处理的数值决定返回小数表示还是指数表示</li></ul><h3 id="string类型的方法"><a href="#string类型的方法" class="headerlink" title="string类型的方法"></a>string类型的方法</h3><ul><li><p>charAt()：以单字符字符串的形式返回给定位置的那个字符；</p></li><li><p>charCodeAt()：返回字符串中给定位置的字符编码值；</p></li><li><p>formCharCode()：把字符串编码还原成字符串；</p></li><li><p>concat()：拼接多个字符串；</p></li><li><p>indexOf(),lastIndexOf()：从头&#x2F;尾查找返回字符串中该字符的位置；</p></li><li><p>trim()：删除前后空格；</p></li><li><p>toLowerCase(),toLocaleLowerCase(),toUpperCase(),toLocaleUpperCase()：大小写转换；</p></li><li><p>text.localCompare(str)：比较两个字符串。返回0表示相等；</p></li><li><p>返回截取字符串的方法：substr(),第二个参数表示返回的字符个数；slice(),substrig()滴二个参数指定子字符串最后一个字符后面的位置。</p><blockquote><p>传入负数时，slice()会将负值与字符串长度相加；substr()将负的第一个参数加上字符串长度，第二个参数转化为0；substring()将所有负值都转化为0。</p></blockquote></li><li><p>字符串的模式匹配：</p><ul><li>text.match(pattern)与正则的pattern.exec(text)相同；</li><li>查找模式方法：text.search(parrent),返回字符串中第一个匹配项的索引；</li><li>replace():替换方法；</li><li>split():指定分隔符分割字符串，结果保存在一个数组中，第二个参数可以指定数组的大小；</li></ul></li></ul><h3 id="Global对象下的方法"><a href="#Global对象下的方法" class="headerlink" title="Global对象下的方法"></a>Global对象下的方法</h3><p>eval():相当于解析器，只有一个字符串参数；</p><p>URI编码方法：</p><ul><li>encodeURI()：对不属于URI的特殊字符编码，对应解码方法decodeURI()；</li><li>encodeURIComponent()：对任何非标准字符编码，对应解码方法decodeURIComponent()；</li></ul><h3 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a>Array方法</h3><p>检测数组：arr instanceof Array，Array.isArray(arr)；</p><p>栈（后进先出）方法：push()在数组末尾添加元素，返回修改后数组的长度；pop()从数组末尾移除最后一项，返回移除的项；</p><p>队列（后进先出）方法：shift()移除数组的第一项并返回该项；unshift()在数组前端添加任意个项并返回新数组的长度；</p><p>重排序方法：reserve()翻转数组项顺序，sort()默认情况按字符串从小到大排序；</p><p>concat():合并数组，返回新数组；</p><p>slice():返回参数指定位置的项；</p><p>splice():根据传入参数，删除项，插入项或者替换项，返回包含删除项的数组；</p><p>迭代方法：</p><ul><li>every(),对数组的每一项给定一个函数，如果每一项都返回true就返回true；</li><li>filter(),对数组的每一项给定一个函数，返回true的项组成的数组；</li><li>forEach(),对数组的每一项给定一个函数，无返回值；</li><li>map():对数组的每一项给定一个函数，返回每次函数调用的结果组成的数组；</li><li>some():对数组的每一项给定一个函数，如果任一项返回true就返回true。</li></ul><h3 id="Function方法"><a href="#Function方法" class="headerlink" title="Function方法"></a>Function方法</h3><p>apply()和call():在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。能扩充函数的定义域。apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。Call()方法第一个参数是this值没有变化，变化的是其余参数直接传递给函数。</p><p>bind():会创建一个函数的实例，其this值会被绑定到传给bind函数的值。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol><li>工厂模式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"B"</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure></li></ol><p>缺点：无法识别对象</p><ol start="2"><li><p>构造函数模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'A'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'B'</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure></li><li><p>原型模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"A"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.name = <span class="string">"B"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//"A"--来自原型</span></span><br><span class="line">alert(person2.name);<span class="comment">//"B"--来自实例,切断了和原型的联系</span></span><br><span class="line">person2.name = <span class="literal">null</span>;</span><br><span class="line">alert(person2.name);<span class="comment">//””</span></span><br></pre></td></tr></table></figure></li><li><p>组合使用构造模型和原型模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>,<span class="string">"b"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>:Person,</span><br><span class="line">	sayName:function()&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"B"</span>,<span class="number">28</span>);</span><br><span class="line">person1.friends.push(<span class="string">"c"</span>);</span><br><span class="line">alert(person1.friends === person2.friends);<span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>动态原型模式</p></li></ol><p>信息封装在构造函数中，通过构造函数初始化原型。不能使用字面量重写原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> Person(<span class="string">"C"</span>,<span class="number">30</span>);</span><br><span class="line">person3.sayName();</span><br></pre></td></tr></table></figure><ol start="6"><li><p>寄生构造函数模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure></li><li><p>稳妥构造函数模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure></li></ol><h3 id="怪癖检测转化为数组"><a href="#怪癖检测转化为数组" class="headerlink" title="怪癖检测转化为数组"></a>怪癖检测转化为数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">  Var array = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    array = <span class="built_in">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//针对非IE浏览器</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>,len = nodes.length; i &lt; len; i++)&#123;</span><br><span class="line">      array.push(nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter组件</title>
    <url>/2019/08/29/Flutter%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>在Flutter中几乎所有的组件都是一个Widget。Widget不仅可以表示UI元素，也可以表示一些功能性的组件。在Flutter中，Widget的功能是“描述一个UI元素的配置数据”。Widget分为有状态StatefulWidget和无状态StatelessWidget两种，StatelessWidget类和StatefulWidget类直接继承自Widget类。</p><a id="more"></a><h4 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h4><p>用于不需要维护状态的场景，通过build返回一个布局好的组件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StatelessWidgetDemo.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessWidgetDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.grey,</span><br><span class="line">        child: Text(<span class="string">"test"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Home.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:testflutter/StatelessWidgetDemo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">   <span class="keyword">return</span> StatelessWidgetDemo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h4><p>用于数据改变的时候，当数据更新时会重新绘制Widget。一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StatefulWidgetDemo.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulWidgetDemo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _StatefulWidgetDemoState createState() =&gt; <span class="keyword">new</span> _StatefulWidgetDemoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StatefulWidgetDemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidgetDemo</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      body:Text(<span class="string">"test2"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本组件（Text、TextSpan）"><a href="#文本组件（Text、TextSpan）" class="headerlink" title="文本组件（Text、TextSpan）"></a>文本组件（Text、TextSpan）</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p>负责显示文本和定义显示样式。</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">data</td><td align="center">String</td><td align="center"></td><td align="center">文本</td></tr><tr><td align="center">maxLines</td><td align="center">int</td><td align="center">0</td><td align="center">最大行数</td></tr><tr><td align="center">textAlign</td><td align="center">TextAlign</td><td align="center">TextAlign.center</td><td align="center">水平对齐</td></tr><tr><td align="center">textDirection</td><td align="center">TextDirection</td><td align="center">TextDirection.ltr</td><td align="center">文本书写方向</td></tr><tr><td align="center">textScaleFactor</td><td align="center">double</td><td align="center">1.0</td><td align="center">字体缩放系数</td></tr><tr><td align="center">style</td><td align="center">TextStyle</td><td align="center">null</td><td align="center">样式</td></tr><tr><td align="center">textSpan</td><td align="center">TextSpan</td><td align="center">null</td><td align="center">文本块</td></tr></tbody></table><p>示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text(<span class="string">"Hello world"</span>,</span><br><span class="line">  maxLines: <span class="number">1</span>,</span><br><span class="line">  overflow: TextOverflow.ellipsis,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    fontSize: <span class="number">18.0</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    fontFamily: <span class="string">"Courier"</span>,</span><br><span class="line">    background: <span class="keyword">new</span> Paint()..color=Colors.yellow,</span><br><span class="line">    decoration:TextDecoration.underline,</span><br><span class="line">    decorationStyle: TextDecorationStyle.dashed</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="TextSpan"><a href="#TextSpan" class="headerlink" title="TextSpan"></a>TextSpan</h4><p>Text的所有文本内容只能按同一种样式，如果我们需要对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan，它代表文本的一个“片段”。示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text.rich(TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">     TextSpan(</span><br><span class="line">       text: <span class="string">"Home: "</span></span><br><span class="line">     ),</span><br><span class="line">     TextSpan(</span><br><span class="line">       text: <span class="string">"https://flutterchina.club"</span>,</span><br><span class="line">       style: TextStyle(</span><br><span class="line">         color: Colors.blue</span><br><span class="line">       ),</span><br><span class="line">       recognizer: _tapRecognizer</span><br><span class="line">     ),</span><br><span class="line">    ]</span><br><span class="line">))</span><br></pre></td></tr></table></figure><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><h4 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h4><p>“漂浮”按钮，它默认带有阴影和灰色背景。示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">"normal"</span>),</span><br><span class="line">  onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h4><p>扁平按钮，默认背景透明并不带阴影。按下后，会有背景色。</p><h4 id="OutlineButton"><a href="#OutlineButton" class="headerlink" title="OutlineButton"></a>OutlineButton</h4><p>默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影。</p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>展示iconfont的组件。Material Design所有图标可以在其<a href="https://material.io/tools/icons/" target="_blank" rel="noopener">官网</a>查看。</p><h4 id="Icons"><a href="#Icons" class="headerlink" title="Icons"></a>Icons</h4><p>框架自带的Icon示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Icon(</span><br><span class="line">        Icons.android,<span class="comment">//图标Icon</span></span><br><span class="line">        color: Colors.green,<span class="comment">//图标颜色，设置为绿色，原本的颜色是黑色的</span></span><br><span class="line">        size: <span class="number">150.0</span>,<span class="comment">//Icon的大小</span></span><br><span class="line">      )</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">icon</td><td align="center">Icons</td><td align="center">null</td><td align="center">展示的图标</td></tr><tr><td align="center">color</td><td align="center">Color</td><td align="center">null</td><td align="center">颜色</td></tr><tr><td align="center">size</td><td align="center">Double</td><td align="center">24.0</td><td align="center">大小</td></tr><tr><td align="center">textDirection</td><td align="center">TextDirection</td><td align="center">TextDirection.ltr</td><td align="center">文本书写方向</td></tr><tr><td align="center">style</td><td align="center">TextStyle</td><td align="center">null</td><td align="center">样式</td></tr></tbody></table><h4 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h4><p>可交互的Icon。支持响应按下事件，如果它的onPressed回调函数为null，那么这个按钮处于禁用的状态，并且不可以按下。</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">icon</td><td align="center">Widget</td><td align="center">null</td><td align="center">必须项，展示的图标</td></tr><tr><td align="center">color</td><td align="center">Color</td><td align="center">null</td><td align="center">颜色</td></tr><tr><td align="center">disabledColor</td><td align="center">Color</td><td align="center">ThemeData.disableColor</td><td align="center">禁用的颜色</td></tr><tr><td align="center">splashColor</td><td align="center">Color</td><td align="center"></td><td align="center">splashColor</td></tr><tr><td align="center">highlightColor</td><td align="center">Color</td><td align="center"></td><td align="center">点击时间稍长的时候背景渐变到这个颜色</td></tr><tr><td align="center">iconSize</td><td align="center">Double</td><td align="center">24.0</td><td align="center">大小</td></tr><tr><td align="center">alignment</td><td align="center">AlignmentGeometry</td><td align="center">TextDirection.ltr</td><td align="center">Icon的对齐方式</td></tr><tr><td align="center">onPressed</td><td align="center">VoidCallBack</td><td align="center">null</td><td align="center">必须项，按下回调事件</td></tr><tr><td align="center">tooltip</td><td align="center">String</td><td align="center"></td><td align="center">按下的提示语</td></tr></tbody></table><h4 id="ImageIcon"><a href="#ImageIcon" class="headerlink" title="ImageIcon"></a>ImageIcon</h4><p>通过AssetImages或者其他图片显示Icon</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">image</td><td align="center">ImageProvider</td><td align="center">必须项</td></tr><tr><td align="center">width&#x2F;height</td><td align="center">double</td><td align="center">Image容器显示区域的宽度和高度</td></tr><tr><td align="center">fit</td><td align="center">BoxFit</td><td align="center">图片填充模式</td></tr><tr><td align="center">color</td><td align="center">Color</td><td align="center">图片的混合色值</td></tr><tr><td align="center">colorBlendMode</td><td align="center">BlendMode</td><td align="center">混合模式</td></tr><tr><td align="center">alignment</td><td align="center">Alignment</td><td align="center">对齐方式</td></tr><tr><td align="center">repeat</td><td align="center">ImageRepeat</td><td align="center">当图片本身大小小于显示空间时，图片重复方式</td></tr><tr><td align="center">centerSlice</td><td align="center">Rect</td><td align="center">拉伸的矩形区域&#x2F;9图的中心区域切片</td></tr><tr><td align="center">matchTextDirection</td><td align="center">bool</td><td align="center">和Directionality配合使用，是否匹配文字分析</td></tr><tr><td align="center">gaplessPlayback</td><td align="center">bool</td><td align="center">图片更新过程中原图是否保留</td></tr><tr><td align="center">semanticLabel</td><td align="center">String</td><td align="center">语义标签</td></tr><tr><td align="center">FilterQuality</td><td align="center">FilterQuality</td><td align="center">过滤器品质</td></tr></tbody></table><p>图片的适应模式:</p><ul><li>BoxFit.none：原始大小</li><li>BoxFit.contain：保持Box的纵横比至至少有一边填充满父控件</li><li>BoxFit.cover：保持Box的纵横比进行缩放至Box完全填充满父控件，超出部分进行裁剪</li><li>BoxFit.fill：Box被完全填充</li><li>BoxFit.fitHeigh：缩放Box高直至填充满父控件</li><li>BoxFit.fitWidth：缩放Box宽直至填充满父控件</li><li>BoxFit.scaleDown：Box大于父控件，则采用与contain一致的缩放模式，否则采用none缩放模式</li></ul><h4 id="加载资源图片"><a href="#加载资源图片" class="headerlink" title="加载资源图片"></a>加载资源图片</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pubspec.yaml</span></span><br><span class="line">assets:</span><br><span class="line">    - images/avatar.png</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Image.asset(<span class="string">"images/avatar.png"</span>,</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//混合模式</span></span><br><span class="line">Image(</span><br><span class="line">  image: AssetImage(<span class="string">"images/avatar.png"</span>),</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  colorBlendMode: BlendMode.difference,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">"https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4"</span>,</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="表单-Form"><a href="#表单-Form" class="headerlink" title="表单(Form)"></a>表单(Form)</h3><p>Form继承自StatefulWidget对象，它对应的状态类为FormState。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Key</td><td align="center">Key</td><td align="center">globalKey,用于获取FormState</td></tr><tr><td align="center">autovalidate</td><td align="center">bool</td><td align="center">是否自动校验输入内容</td></tr><tr><td align="center">child</td><td align="center">Widget</td><td align="center">组件child只能有一个组件</td></tr><tr><td align="center">onChange</td><td align="center">VoidCallback</td><td align="center">当FormField值改变时的回调函数</td></tr><tr><td align="center">onWillPop</td><td align="center">WillPopCallback</td><td align="center">决定Form在的路由是否能直接返回</td></tr></tbody></table><p>FormState可以通过Form.of()或GlobalKey获得。我们可以通过它来对Form的子孙FormField进行统一操作。</p><ul><li>FormState.validate()：调用FormField的validate回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。</li><li>FormState.save()：调用FormField的save回调，用于保存表单内容</li><li>FormState.reset()：清空FormField的内容。</li></ul><h3 id="输入框（TextField、TextFormField）"><a href="#输入框（TextField、TextFormField）" class="headerlink" title="输入框（TextField、TextFormField）"></a>输入框（TextField、TextFormField）</h3><p>用于文本输入，输入框是比较复杂的组件了。<a href>属性详情</a></p><h3 id="单选框和复选框（）"><a href="#单选框和复选框（）" class="headerlink" title="单选框和复选框（）"></a>单选框和复选框（）</h3><p>单选开关Switch和复选框Checkbox都是继承自StatelessWidget，所以它们本身不会保存当前选择状态，因此它们的选中状态都是由父组件来管理的。当Switch或Checkbox被点击时，会触发它们的onChanged回调，可以在此回调中处理选中状态改变逻辑。</p><h2 id="滚动组件"><a href="#滚动组件" class="headerlink" title="滚动组件"></a>滚动组件</h2><h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h3 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h3><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>可以设置大小和装饰的容器。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">alignment</td><td align="center">Alignment</td><td align="center">对齐方式</td></tr><tr><td align="center">child</td><td align="center">Widget</td><td align="center">子元素</td></tr><tr><td align="center">width</td><td align="center">double</td><td align="center">宽度</td></tr><tr><td align="center">height</td><td align="center">double</td><td align="center">高度</td></tr><tr><td align="center">padding</td><td align="center">EdgeInsets</td><td align="center">内边距</td></tr><tr><td align="center">margin</td><td align="center">EdgeInsets</td><td align="center">外边距</td></tr><tr><td align="center">color</td><td align="center">Color</td><td align="center">背景颜色(不能与decoration一块设置)</td></tr><tr><td align="center">decoration</td><td align="center">BoxDecoration</td><td align="center">背景装饰</td></tr><tr><td align="center">foregroundDecoration</td><td align="center">Decoration</td><td align="center">前景装饰</td></tr><tr><td align="center">transform</td><td align="center">Matrix4</td><td align="center">变换(转换矩阵)</td></tr><tr><td align="center">constraints</td><td align="center">BoxConstraints</td><td align="center">容器大小的限制条件</td></tr></tbody></table><h3 id="SizeBox"><a href="#SizeBox" class="headerlink" title="SizeBox"></a>SizeBox</h3><h3 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h3><p>Scaffold实现了基本的material风格的布局结构，包含了导航栏，抽屉菜单，底部导航等。常用属性如下：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">appBar</td><td align="center">AppBar</td><td align="center">顶部导航栏</td></tr><tr><td align="center">backgroundColor</td><td align="center">Color</td><td align="center">背景色</td></tr><tr><td align="center">body</td><td align="center">Widget</td><td align="center">内容元素</td></tr><tr><td align="center">bottomNavigationBar</td><td align="center">BottomNavigationBar</td><td align="center">底部导航栏</td></tr><tr><td align="center">drawer</td><td align="center">Drawer</td><td align="center">抽屉菜单</td></tr><tr><td align="center">floatingActionButton</td><td align="center">FloatingActionButton</td><td align="center">悬浮按钮</td></tr></tbody></table><h3 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h3><p>一个Material风格的导航栏，通过它可以设置导航栏标题、导航栏菜单、导航栏底部的Tab标题等。常用属性如下：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">actions</td><td align="center">List<widget></widget></td><td align="center">导航栏右侧菜单</td></tr><tr><td align="center">backgroundColor</td><td align="center">Color</td><td align="center">背景色</td></tr><tr><td align="center">title</td><td align="center"></td><td align="center">标题</td></tr><tr><td align="center">leading</td><td align="center">Widget</td><td align="center">导航栏左侧Widget</td></tr><tr><td align="center">bottom</td><td align="center">Widget</td><td align="center">导航栏底部菜单</td></tr><tr><td align="center">centerTitle</td><td align="center">bool</td><td align="center">标题是否居中</td></tr><tr><td align="center">elevation</td><td align="center">double</td><td align="center">导航栏阴影大小</td></tr></tbody></table><h3 id="TabBar和TabBarView"><a href="#TabBar和TabBarView" class="headerlink" title="TabBar和TabBarView"></a>TabBar和TabBarView</h3><h3 id="Card"><a href="#Card" class="headerlink" title="Card"></a>Card</h3><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><h3 id="Chip"><a href="#Chip" class="headerlink" title="Chip"></a>Chip</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flutterchina.club/widgets/" target="_blank" rel="noopener">Widgets 目录</a></p><p><a href="https://book.flutterchina.club/chapter4/wrap_and_flow.html" target="_blank" rel="noopener">《Flutter实战》</a></p><p><a href="https://www.cnblogs.com/upwgh/p/11241818.html" target="_blank" rel="noopener">Flutter学习笔记</a></p>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3的几个新特性</title>
    <url>/2022/02/14/Vue3%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>Composition API 也叫组合式 API，它主要就是为了解决 Vue2 中 Options API 的问题。</p><blockquote><p>vue2中，我们在methods、computed、watch、data中定义属性和方法，共同处理页面逻辑，我们称这种方式为Options API。<br>这种代码模式下存在几个问题：</p><ul><li>随着功能的增长，复杂组件的代码变得越来越难以维护。 尤其去新接手别人的代码时。 根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。</li><li>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。</li><li>类型推断不够友好。</li></ul></blockquote><a id="more"></a><blockquote><p>Composition API顾名思义就是不再传入data、mounted等参数，通过引入的ref、onMounted等方法实现数据的双向绑定、生命周期函数的执行。Composition API目的是通过一组低侵入式的、函数式的 API，使得我们能够更灵活地「组合」组件的逻辑，因此其中的代码是根据逻辑功能来组织的，同一功能所定义的所有api会放在一起。</p></blockquote><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>vue3中使用<code>setup</code>代替了<code>beforeCreate</code>和<code>created</code>这两个生命周期，<code>setup()</code>是在创建vue组件实例并完成props的初始化之后执行（在 created() 生命周期函数之前执行）。同时setup返回的值，可以在模板和其他option中使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setup(props, context)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    text: <span class="string">'test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Vue2区别：</p><p>不能使用this，而是通过 context 对象来代替当前执行上下文绑定的对象，context 对象有四个属性：attrs、slots、emit、expose。</p><h3 id="ref、reactive"><a href="#ref、reactive" class="headerlink" title="ref、reactive"></a>ref、reactive</h3><p>reactive 和 ref 都是用来定义响应式数据的。一般来说，<code>ref</code>用于基础赋值类型的数据，而<code>reactive</code>用于引用类型的数据。ref 的底层就是 reactive。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p><code>ref</code>函数传入一个值作为参数，一般传入基本数据类型，<code>ref</code>的返回值是一个对象，这个对象上只包含一个<code>.value</code>属性。（可以理解为ref是在reactive上的封装）</p><blockquote><ul><li>基本类型数据：响应式依然是通过Object.defineProperty()。</li><li>引用类型数据：响应式是通过调用内部方法reactive函数（通过Proxy）</li></ul></blockquote><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p><code>reactive</code>是用来定义更加复杂的数据类型，但是解构就不具备响应式了（相当于跳过了代理重新赋新值了）。</p><h4 id="toRef-和-toRefs"><a href="#toRef-和-toRefs" class="headerlink" title="toRef 和 toRefs"></a>toRef 和 toRefs</h4><p>toRef是将对象中的某个值转化为响应式数据 toRef(obj, key)。</p><p><code>toRefs</code>函数可以将<code>reactive</code>创建出来的响应式对象转换为普通的对象，这个对象上的每个属性都是<code>Ref</code>类型的响应式数据。</p><p>toRef和toRefs是对原始数据的引用，修改响应式数据时，原始数据也会发生改变，但是视图并不会更新。toRef修改的是对象的某个属性，toRefs修改的是整个对象</p><h4 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h4><p>判断是否是ref对象。</p><h4 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h4><p>返回ref的<code>.value</code>值，或返回原值。</p><h3 id="watch、watchEffect"><a href="#watch、watchEffect" class="headerlink" title="watch、watchEffect"></a>watch、watchEffect</h3><p>watch与watchEffect的差别是，watchEffect会立马执行，执行中被读取的响应式 数据会被观测。而watch只有在watch对象有变化时才会执行。</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch 作用是监听传值（和Vue2一致，是惰性的，会返回新值和旧值）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ref 数据</span></span><br><span class="line"><span class="keyword">const</span> name = ref(<span class="string">'name1'</span>)</span><br><span class="line">watch(</span><br><span class="line">  name,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;&#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive 数据</span></span><br><span class="line"><span class="keyword">const</span> user = reactive(&#123; <span class="attr">name</span>: <span class="string">'username'</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; user.name,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数据</span></span><br><span class="line">watch(</span><br><span class="line">  [name, () =&gt; user.name],</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>与Vue2区别：</p><ol><li>传参不一样，watch需要传监听的响应式变量，回调函数，options配置</li><li>停止监听: 在组件中创建的watch监听，会在组件被销毁时自动停止。如果在组件销毁之前想要停止掉某个监听， 可以调用watch()函数的返回值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> watchFun = watch(</span><br><span class="line">  name,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;&#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 停止监听</span></span><br><span class="line">  watchFun()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p>watchEffect用法和watch不一样。watchEffect 是传入一个立即执行函数，所以默认第一次也会执行一次；不需要传入监听内容，会自动收集函数内的数据源作为依赖，在依赖变化的时候又会重新执行该函数，如果没有依赖就不会执行；而且不会返回变化前后的新值和老值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><ul><li>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method</li><li>onBeforeMount() : 组件挂载到节点上之前执行的函数。</li><li>onMounted() : 组件挂载完成后执行的函数。</li><li>onBeforeUpdate(): 组件更新之前执行的函数。</li><li>onUpdated(): 组件更新完成之后执行的函数。</li><li>onBeforeUnmount(): 组件卸载之前执行的函数。</li><li>onUnmounted(): 组件卸载完成后执行的函数</li><li>onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。</li><li>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。</li><li>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数（以后用到再讲，不好展现）。</li></ul><h2 id="Fragment-碎片化节点"><a href="#Fragment-碎片化节点" class="headerlink" title="Fragment(碎片化节点)"></a>Fragment(碎片化节点)</h2><p>vue3组件的模板结构中出现多个标签时，可以不用根标签。编译时vue会在这些元素节点上添加一个<code>&lt;Fragment&gt;&lt;/Fragment&gt;</code>标签。并且该标签不会出现在dom树中。</p><h2 id="Suspense-异步组件"><a href="#Suspense-异步组件" class="headerlink" title="Suspense(异步组件)"></a>Suspense(异步组件)</h2><p>vue3中提供一个<code>&lt;Suspense&gt;&lt;/Suspense&gt;</code>组件用于控制异步组件。</p><blockquote><p>作用：等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></blockquote><p>使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异步组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-component</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">    加载中 ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Teleport（传送门）"><a href="#Teleport（传送门）" class="headerlink" title="Teleport（传送门）"></a>Teleport（传送门）</h2><blockquote><p><teleport>是一个内置组件，使我们可以将一个组件的一部分模板“传送”到该组件的 DOM 层次结构之外的 DOM 节点中。</teleport></p></blockquote><p>使用场景：有时组件模板的一部分逻辑上属于该组件，但元素上最好将模板的这一部分移动到组件之外的其他位置。比如点击按钮出现的弹出框。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 渲染到body标签下</span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">    模态框</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS算法</title>
    <url>/2018/03/26/JS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>有时候突然来了兴趣想练习下算法题，以下的算法题都是从各种博客和coderbyte上找来的。<br>coderbyte上的题目还是挺有意思的 (๑•̀ㅂ•́)و✧</p><p>虽然这些题目都比较基础，不过也有好些做不出来的，或者做出来了想的也有点复杂来着 ━(￣ー￣*|||━━</p><a id="more"></a><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p>这是很经典的算法题了。最开始我是这样写的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removal</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	arr=arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a-b;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">var</span> ret = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] !== arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">			ret.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写有比较复杂，后来我改成了这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removal</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ret.indexOf(arr[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">			ret.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removal</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret = [];</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">		<span class="keyword">var</span> key = arr[j];</span><br><span class="line">		<span class="keyword">if</span> (!obj[key]) &#123;</span><br><span class="line">			obj[key] = <span class="number">1</span>;</span><br><span class="line">			ret.push(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上网上看到的用ES6新特性Set去重：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove2</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> single2 = remove2(arr1);</span><br></pre></td></tr></table></figure><h4 id="判断字符串是否是回文"><a href="#判断字符串是否是回文" class="headerlink" title="判断字符串是否是回文"></a>判断字符串是否是回文</h4><p>比如：redivider是回文</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"redivider"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPalindrom</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str == str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串中出现最多的字母"><a href="#字符串中出现最多的字母" class="headerlink" title="字符串中出现最多的字母"></a>字符串中出现最多的字母</h4><p>比如：”afjghdfraaaasdenas”</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"afjghdfraaaasdenas"</span>;</span><br><span class="line"><span class="keyword">var</span> arr3 = str1.split(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;,num = <span class="number">0</span>,ret2 = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; arr3.length; k++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!obj[arr3[k]])&#123;</span><br><span class="line">		obj[arr3[k]] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// num++;</span></span><br><span class="line">	&#125;</span><br><span class="line">	obj[arr3[k]] ++;</span><br><span class="line">	ret2.push(obj[arr3[k]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> max= <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,ret2);</span><br><span class="line"><span class="built_in">console</span>.log(arr3[ret2.indexOf(max)]);</span><br></pre></td></tr></table></figure><p>网上看到的其他方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> charObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!charObj[str.charAt(i)]) &#123;</span><br><span class="line">      charObj[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      charObj[str.charAt(i)] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxChar = <span class="string">''</span>,</span><br><span class="line">      maxValue = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> charObj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">      maxChar = k;</span><br><span class="line">      maxValue = charObj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxChar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = findMaxDuplicateChar;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; l; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">let</span> tem = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成指定长度的斐波那契数列"><a href="#生成指定长度的斐波那契数列" class="headerlink" title="生成指定长度的斐波那契数列"></a>生成指定长度的斐波那契数列</h4><p>例如：[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawfeibo</span>(<span class="params">l</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; l; i++)&#123;</span><br><span class="line">		arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取正数组的最大差值"><a href="#获取正数组的最大差值" class="headerlink" title="获取正数组的最大差值"></a>获取正数组的最大差值</h4><p>比如数组[10,5,11,7,8,9]，输出6</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDvalue</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//var arr = [10,5,11,7,8,9];</span></span><br><span class="line">	<span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line">	<span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr);</span><br><span class="line">	<span class="keyword">var</span> D_value = max - min;</span><br><span class="line">	<span class="keyword">return</span> D_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h4><p>比如：给定长度 8 输出 4ldkfg9j</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStr</span>(<span class="params">l</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">'abcdefghijklmnopqrstuvwxyz9876543210'</span>;</span><br><span class="line">	<span class="keyword">var</span> arr = str.split(<span class="string">''</span>),arr2 = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> temp = arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br><span class="line">		arr2.push(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result = arr2.join(<span class="string">''</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上看到的其他方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">'abcdefghijklmnopqrstuvwxyz9876543210'</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="string">''</span>,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      l = str.length;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    tmp += str.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * l));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = randomString;</span><br></pre></td></tr></table></figure><h4 id="字符的左右移动"><a href="#字符的左右移动" class="headerlink" title="字符的左右移动"></a>字符的左右移动</h4><p>给定一个字符串，这个字符串为号和26个字母的任意组合。现在需要把字符串中的号都移动到最左侧，而把字符串中的字母移到最右侧并保持相对顺序不变。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'sosunn**afns*repsni*'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortstring</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">		<span class="keyword">var</span> number = [], zimu = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].charCodeAt()&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">				number.push(arr[i]);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				zimu.push(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> newstr = number.concat(zimu).join(<span class="string">''</span>);</span><br><span class="line">		<span class="keyword">return</span> newstr;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>网上看到的其他方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortstring</span>(<span class="params">stars</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> rs = stars.split(<span class="string">''</span>);</span><br><span class="line">	<span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=rs.length <span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(rs[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">					flag++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">							rs[i+flag] = rs[i];</span><br><span class="line">							rs[i] = <span class="string">'*'</span>;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rs.join(<span class="string">''</span>); <span class="comment">//****sosunnafnsrepsni</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在一个字符串中找到第一个只出现一次的字符"><a href="#在一个字符串中找到第一个只出现一次的字符" class="headerlink" title="在一个字符串中找到第一个只出现一次的字符"></a>在一个字符串中找到第一个只出现一次的字符</h4><p>如输入abaccdefbf，则输出d<br>我开始是这样想的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfirstchar</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr=str.split(<span class="string">''</span>);</span><br><span class="line">	<span class="keyword">var</span> ret=[],arrnew=[];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">		ret.push(arr[i].charCodeAt());<span class="comment">//ASCII</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret = ret.sort();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; ret.length; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ret[k] != ret[k + <span class="number">1</span>])&#123;</span><br><span class="line">			arrnew.push(ret[k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(arrnew[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过后来感觉我的时间复杂度比较高，这是网上看到的其他方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abaccdefbf'</span>;</span><br><span class="line"><span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> rs = str.split(<span class="string">''</span>);</span><br><span class="line">rs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">al</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(results[al] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">				results[al] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				results[al]++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(results);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(results[keys[i]] === <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(keys[i]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回句子中第一次出现的最长的单词"><a href="#返回句子中第一次出现的最长的单词" class="headerlink" title="返回句子中第一次出现的最长的单词"></a>返回句子中第一次出现的最长的单词</h4><p>比如：’I love dogs ss’，返回 love；’fub&amp;!!time’，返回time</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LongestWord</span>(<span class="params">sen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pat = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[`~!@#$^&amp;*=+|&#123;&#125;\\[\\]()&lt;&gt;~@%#￥&amp;*——|&#123;&#125;【】？]"</span>, <span class="string">'g'</span>);</span><br><span class="line">    <span class="keyword">var</span> arr = sen.replace(pat,<span class="string">' '</span>).split(<span class="string">' '</span>);</span><br><span class="line">	arr = arr.reverse();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">1</span>; n &lt; arr.length; n++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[n - <span class="number">1</span>].length &gt;= arr[n].length)&#123;</span><br><span class="line">			<span class="keyword">var</span> result = arr[n - <span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从数组中移除"><a href="#从数组中移除" class="headerlink" title="从数组中移除"></a>从数组中移除</h4><p>比如：destroyer([[1, 2, 3, 1, 2, 3], 2, 3])，输出[1,1]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret = array;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; array[<span class="number">0</span>].length; k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; ret.length; j++)&#123;</span><br><span class="line">			array[<span class="number">0</span>].splice(array[<span class="number">0</span>].indexOf(ret[j]),<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">destroyer([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h4 id="输出一个数字的二进制中1的个数"><a href="#输出一个数字的二进制中1的个数" class="headerlink" title="输出一个数字的二进制中1的个数"></a>输出一个数字的二进制中1的个数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">geterjinzhi</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> index=<span class="number">0</span>,</span><br><span class="line">		number = <span class="built_in">parseInt</span>(num,<span class="number">16</span>).toString(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">var</span> arr = number.split(<span class="string">''</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; arr.length; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[k] == <span class="number">1</span>)&#123;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayAdditionI"><a href="#ArrayAdditionI" class="headerlink" title="ArrayAdditionI"></a>ArrayAdditionI</h4><p>Have the function ArrayAdditionI(arr) take the array of numbers stored in arr and return the string true if any combination of numbers in the array can be added up to equal the largest number in the array, otherwise return the string false. For example: if arr contains [4, 6, 23, 10, 1, 3] the output should return true because 4 + 6 + 10 + 3 &#x3D; 23. The array will not be empty, will not contain all the same elements, and may contain negative numbers.</p><p>比如： ArrayAddition([1, 22, 23, 25, 26]), 输出true，<br>ArrayAddition([1, 22, 23, 24, 27, 29, 33]), 输出false，<br>ArrayAddition([4, 6, 23, 10, 1, 3]), 输出true</p><p>这是很久之前写的代码，写的很复杂，我也不是很理解当时的脑回路了&#x3D; &#x3D; 大概类似于排列组合吧<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayAddition</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line"> arr.splice(arr.indexOf(max),<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">var</span> num = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">xunhuan</span>(<span class="params">n,array</span>)</span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(n != max)&#123;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">var</span> m = <span class="number">1</span>; m &lt; arr.length; m++)&#123;</span><br><span class="line">			 <span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; array.length; index++)&#123;</span><br><span class="line">				 <span class="keyword">if</span>(array[array.length<span class="number">-1</span>] + m &lt; arr.length)&#123;</span><br><span class="line">					 n += arr[array[array.length<span class="number">-1</span>] + m];</span><br><span class="line">					 array.push(array[array.length<span class="number">-1</span>] + m);</span><br><span class="line">					n = xunhuan(n,array);</span><br><span class="line">				 &#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		 flag = <span class="literal">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">1</span>; k &lt; arr.length; k++)&#123;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			 <span class="keyword">var</span> newarr = [];</span><br><span class="line">			 num = arr[i] + arr[k];</span><br><span class="line">			 newarr.push(i);</span><br><span class="line">			 newarr.push(k);</span><br><span class="line">			 num = xunhuan(num,newarr);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'ArrayAddition'</span>,flag)</span><br><span class="line"> <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>比如：if num &#x3D; 4, return (4 * 3 * 2 * 1))</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstFactorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> reslut = num;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">1</span>; k &lt; num; k++)&#123;</span><br><span class="line">		reslut *= k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h4 id="输入分钟输出时间显示"><a href="#输入分钟输出时间显示" class="headerlink" title="输入分钟输出时间显示"></a>输入分钟输出时间显示</h4><p>return the number of hours and minutes the parameter converts to (ie. if num &#x3D; 63 then the output should be 1:3).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeConvert</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="built_in">Math</span>.floor(num/<span class="number">60</span>) + <span class="number">1</span>,n = <span class="string">''</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= a; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> b = i* <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">if</span>( num &gt; b)&#123;</span><br><span class="line">			 n = num - b;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			 n = num - <span class="number">60</span> * (i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> str = (a<span class="number">-1</span>) + <span class="string">':'</span> + n;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">TimeConvert(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="return-the-string-with-the-letters-in-alphabetical-order"><a href="#return-the-string-with-the-letters-in-alphabetical-order" class="headerlink" title="return the string with the letters in alphabetical order"></a>return the string with the letters in alphabetical order</h4><p>比如：ie. hello becomes ehllo.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AlphabetSoup</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> arr = str.split(<span class="string">''</span>),ret = [],newarr = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			ret.push(arr[i].charCodeAt());</span><br><span class="line">		&#125;</span><br><span class="line">		ret.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a - b;&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; ret.length; k++)&#123;</span><br><span class="line">			newarr.push(<span class="built_in">String</span>.fromCharCode(ret[k]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newarr.join(<span class="string">''</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> AlphabetSoup(<span class="string">'coderbyte'</span>);</span><br></pre></td></tr></table></figure><h4 id="the-string-to-be-true-each-letter-must-be-surrounded-by-a-symbol"><a href="#the-string-to-be-true-each-letter-must-be-surrounded-by-a-symbol" class="headerlink" title="the string to be true each letter must be surrounded by a + symbol"></a>the string to be true each letter must be surrounded by a + symbol</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simplesymbols</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> arr = str.split(<span class="string">''</span>), html = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[<span class="number">0</span>].charCodeAt()&gt;=<span class="number">97</span> || arr[arr.length - <span class="number">1</span>].charCodeAt()&gt;=<span class="number">97</span>)&#123;</span><br><span class="line">			html = <span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> h = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i].charCodeAt()&gt;=<span class="number">97</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[i - <span class="number">1</span>] === <span class="string">'+'</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(arr[i + <span class="number">1</span>] === <span class="string">'+'</span>)&#123;</span><br><span class="line">							html = <span class="literal">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				h = h &amp;&amp; html;</span><br><span class="line">			&#125;</span><br><span class="line">			html = h;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> html;</span><br><span class="line">	&#125;</span><br><span class="line"> simplesymbols(<span class="string">"=d+=3=+s+"</span>);</span><br></pre></td></tr></table></figure><h4 id="capitalize-the-first-letter-of-each-word"><a href="#capitalize-the-first-letter-of-each-word" class="headerlink" title="capitalize the first letter of each word"></a>capitalize the first letter of each word</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lettercapitalize</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">	arr[<span class="number">0</span>] = <span class="built_in">String</span>.fromCharCode(arr[<span class="number">0</span>].charCodeAt() - <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; arr.length<span class="number">-1</span>; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[k] === <span class="string">' '</span>)&#123;</span><br><span class="line">			arr[k+<span class="number">1</span>] = <span class="built_in">String</span>.fromCharCode(arr[k+<span class="number">1</span>].charCodeAt() - <span class="number">32</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> newstr = arr.join(<span class="string">''</span>);</span><br><span class="line">	<span class="keyword">return</span> newstr;</span><br><span class="line">&#125;</span><br><span class="line">lettercapitalize(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><h4 id="判断是不是质数"><a href="#判断是不是质数" class="headerlink" title="判断是不是质数"></a>判断是不是质数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> html = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; num; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> n = num % i;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在刚刚的方法基础上获取质数因子"><a href="#在刚刚的方法基础上获取质数因子" class="headerlink" title="在刚刚的方法基础上获取质数因子"></a>在刚刚的方法基础上获取质数因子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">primeFactors</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; num; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(isPrime(i))&#123;</span><br><span class="line">				arr.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greatestCommonDivisor</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = num1;</span><br><span class="line">	<span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">		 num = num2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; num; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">			arr.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输入两个数组，得到不在另一个数组中的值组成的新数组"><a href="#输入两个数组，得到不在另一个数组中的值组成的新数组" class="headerlink" title="输入两个数组，得到不在另一个数组中的值组成的新数组"></a>输入两个数组，得到不在另一个数组中的值组成的新数组</h4><p>列如：[1, 2, 3, 5], [1, 2, 3, 4, 5] return [4]<br>[1, “calf”, 3, “piglet”],[1, “calf”, 3, 4] return [“piglet”,’4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueFromnArr</span>(<span class="params">arr1,arr2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret = [];</span><br><span class="line">	<span class="keyword">var</span> array = [arr1,arr2].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a.length-b.length&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[<span class="number">0</span>].indexOf(array[<span class="number">1</span>][i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">			ret.push(array[<span class="number">1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(array[<span class="number">1</span>].indexOf(array[<span class="number">0</span>][i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">			ret.push(array[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = array[<span class="number">0</span>].length; k &lt; array[<span class="number">1</span>].length; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[<span class="number">0</span>].indexOf(array[<span class="number">1</span>][k]) == <span class="number">-1</span>)&#123;</span><br><span class="line">			ret.push(array[<span class="number">1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> newArr = [];</span><br><span class="line">	<span class="comment">//过滤数组1中与数组2相等的项</span></span><br><span class="line">	<span class="keyword">var</span> arr1Filtered=arr1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr2.length; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num==arr2[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//过滤数组2中与数组1相等的项</span></span><br><span class="line">	<span class="keyword">var</span> arr2Filtered=arr2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr1.length; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num==arr1[i])&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//连接两个数组</span></span><br><span class="line">	newArr=arr1Filtered.concat(arr2Filtered);</span><br><span class="line">	<span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断两个Object是不是相等"><a href="#判断两个Object是不是相等" class="headerlink" title="判断两个Object是不是相等"></a>判断两个Object是不是相等</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectEqual</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> obj1 == <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj2 == <span class="string">'object'</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> count = <span class="number">0</span>,len = <span class="built_in">Object</span>.keys(obj1).length;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="built_in">Object</span>.keys(obj2).length)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">typeof</span> obj2[key] != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(obj1[key] == obj2[key])&#123;</span><br><span class="line">						count ++;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(len == count)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上看到的另一个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">collection, source</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">var</span> porp=<span class="built_in">Object</span>.keys(source);</span><br><span class="line">	arr=collection.filter(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;porp.length; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(obj[porp[i]]!==source[porp[i]])&#123;</span><br><span class="line">				<span class="comment">//判断参数1中各个对象的porp属性的值是否与参数二中的porp属性值相等</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找到字符串中缺失的字母"><a href="#找到字符串中缺失的字母" class="headerlink" title="找到字符串中缺失的字母"></a>找到字符串中缺失的字母</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fearNotLetter</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = str.split(<span class="string">""</span>),ret=[];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">		arr[i] = arr[i].charCodeAt();</span><br><span class="line">	&#125;</span><br><span class="line">	arr = arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;a-b&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k = arr[<span class="number">0</span>]; k &lt; arr[arr.length<span class="number">-1</span>]; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr.indexOf(k) == <span class="number">-1</span>)&#123;</span><br><span class="line">			ret.push(<span class="built_in">String</span>.fromCharCode(k));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fearNotLetter</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//将字符串转为ASCII码，并存入数组</span></span><br><span class="line">	<span class="keyword">var</span> arr=[];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;str.length; i++)&#123;</span><br><span class="line">		arr.push(str.charCodeAt(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">		<span class="keyword">var</span> num=arr[j]-arr[j<span class="number">-1</span>];</span><br><span class="line">		<span class="comment">//判断后一项减前一项是否为1，若不为1，则缺失该字符的前一项</span></span><br><span class="line">		<span class="keyword">if</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//将缺失字符ASCII转为字符并返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(arr[j]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取多个数组的组合数组并去重"><a href="#获取多个数组的组合数组并去重" class="headerlink" title="获取多个数组的组合数组并去重"></a>获取多个数组的组合数组并去重</h4><p>比如：getSortAndUniteArr([1, 3, 2], [5, 2, 1, 4], [2, 1]) return [1, 3, 2, 5, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSortAndUniteArr</span>(<span class="params">arr1,...arr3</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret = [],obj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">var</span> arr = arr1.concat(...arr3);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> k = arr[i];</span><br><span class="line">		<span class="keyword">if</span>(!obj[k])&#123;</span><br><span class="line">			obj[k] = <span class="number">1</span>;</span><br><span class="line">			ret.push(k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上看到的另一个方法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unite</span>(<span class="params">arr1, arr2, arr3</span>) </span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;<span class="built_in">arguments</span>.length; j++)&#123;</span><br><span class="line">	    <span class="comment">//过滤掉第j个数组中已经在前面出现过的值</span></span><br><span class="line">	    <span class="keyword">var</span> filteredArr=<span class="built_in">arguments</span>[j].filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr1.length; i++)&#123;</span><br><span class="line">	        <span class="keyword">if</span>(arr1[i]==num)&#123;</span><br><span class="line">	          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	      &#125;</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	    &#125;);</span><br><span class="line">	    arr1=arr1.concat(filteredArr);</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> arr1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/lvmylife/p/7208541.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvmylife/p/7208541.html</a></p><p><a href="https://coderbyte.com/" target="_blank" rel="noopener">https://coderbyte.com</a></p><p><a href="https://blog.csdn.net/crystal6918/article/details/60955989" target="_blank" rel="noopener">https://blog.csdn.net/crystal6918/article/details/60955989</a></p>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2019/04/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程，在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><p>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期。</p><a id="more"></a><h3 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h3><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><p>el 和 data 并未初始化。在实例初始化之后，数据观测(data observer) 和 event&#x2F;watcher 事件配置之前被调用。</p><h4 id="在beforeCreate和created钩子函数之间的生命周期"><a href="#在beforeCreate和created钩子函数之间的生命周期" class="headerlink" title="在beforeCreate和created钩子函数之间的生命周期"></a>在beforeCreate和created钩子函数之间的生命周期</h4><h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><p>完成了 data 数据的初始化，el未初始化。实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 主要应用：调用数据，调用方法，调用异步函数。</p><p>created钩子可以获取Vue的data，调用Vue方法，获取原本HTML上的直接加载出来的DOM，但是无法获取到通过挂载模板生成的DOM（例如：v-for循环遍历Vue.list生成li）</p><h4 id="created钩子函数和beforeMount间的生命周期"><a href="#created钩子函数和beforeMount间的生命周期" class="headerlink" title="created钩子函数和beforeMount间的生命周期"></a>created钩子函数和beforeMount间的生命周期</h4><p>首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</p><p>template参数选项的有无对生命周期的影响。</p><ul><li>如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。</li><li>如果没有template选项，则将外部HTML作为模板编译。</li><li>可以看到template中的模板优先级要高于outer HTML的优先级。</li></ul><p>在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.（嵌入JSX应该要引入babel-plugin-transform-vue-jsx这个插件）</p><p>优先级：render函数选项 &gt; template选项 &gt; outer HTML.</p><h4 id="beforeMount和mounted-钩子函数间的生命周期"><a href="#beforeMount和mounted-钩子函数间的生命周期" class="headerlink" title="beforeMount和mounted 钩子函数间的生命周期"></a>beforeMount和mounted 钩子函数间的生命周期</h4><p>给vue实例对象添加$el成员，并且替换掉挂载的DOM元素。beforeMount之前el上还是undefined。</p><ul><li>beforeMount:在挂载开始之前被调用：相关的 render 函数（模板）首次被调用。 例如通过v-for生成的html还没有被挂载到页面上</li></ul><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 有初始值的DOM渲染，可以对DOM进行操作。</p><p>当你vue没有挂在el时，我们可以用$mount</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;<span class="attr">message</span>:<span class="string">'hello'</span>&#125;,</span><br><span class="line">&#125;).$mount(#app);</span><br></pre></td></tr></table></figure><h4 id="beforeUpdate钩子函数和updated钩子函数间的生命周期"><a href="#beforeUpdate钩子函数和updated钩子函数间的生命周期" class="headerlink" title="beforeUpdate钩子函数和updated钩子函数间的生命周期"></a>beforeUpdate钩子函数和updated钩子函数间的生命周期</h4><p>data中的数据发生了改变，会触发对应组件的重新渲染</p><ul><li>beforeUpdate:数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 当我们更改Vue的任何数据，都会触发该函数</li><li>updated:组件 DOM 已经更新,可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</li></ul><h4 id="beforeDestroy和destroyed钩子函数间的生命周期"><a href="#beforeDestroy和destroyed钩子函数间的生命周期" class="headerlink" title="beforeDestroy和destroyed钩子函数间的生命周期"></a>beforeDestroy和destroyed钩子函数间的生命周期</h4><ul><li>beforeDestroy:实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000011381906?utm_source=tag-newest" target="_blank" rel="noopener">详解vue生命周期</a></p>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Less与Sass</title>
    <url>/2018/03/07/Less%E4%B8%8ESass/</url>
    <content><![CDATA[<p>Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。</p><p>Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数. Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。</p><a id="more"></a><h2 id="共性："><a href="#共性：" class="headerlink" title="共性："></a>共性：</h2><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p><font color="#63ca87">混合</font>，主要意思是将一个定义好的class A引入到另一个class B中，从而简单实现class B继承了class A的所有属性。</p><h4 id="Parametric"><a href="#Parametric" class="headerlink" title="Parametric"></a>Parametric</h4><p><font color="#63ca87">带参数混合</font>，像函数一样在class A中定义一个参数的默认值、或者参数属性集合，还可以是<code>@arguments</code>常量，然后将定义好的class A引入class B中。</p><h4 id="Nested-Rules"><a href="#Nested-Rules" class="headerlink" title="Nested Rules"></a>Nested Rules</h4><p><font color="#63ca87">嵌套规则</font>，指的是在一个选择器中嵌套另一个选择器来实现继承。从而减少了代码量，并且增加了代码的可读性。</p><h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><p><font color="#63ca87">运算</font>，在CSS中使用加、减、乘、除进行数学运算，主要运用于属性值和颜色的运算，可以轻松实现属性值之间的复杂关系。</p><h4 id="Color-function"><a href="#Color-function" class="headerlink" title="Color function"></a>Color function</h4><p><font color="#63ca87">颜色功能</font>，颜色的函数运算，颜色会先被转化成HSL色彩空间，然后在通道级别操作。</p><h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p><font color="#63ca87">命名空间</font>，将一些变量或者混合模块打包封装，更好的组织CSS和属性集的重复使用；</p><h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p><font color="#63ca87">作用域</font>，先从本地查找变量或者混合模块，如果没有找到的话就会去父级作用域中查找，直到找到为止，这一点和其他程序语言的作用域非常的相似；</p><h4 id="Javascript-evaluation"><a href="#Javascript-evaluation" class="headerlink" title="Javascript evaluation"></a>Javascript evaluation</h4><p><font color="#63ca87">javascript的表达式</font>，在Less或sass文件中可以使用js的表达式,用来赋值。</p><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现方式不同。LESS是基于JavaScript运行，所以LESS是在客户端处理。Sass是基于Ruby的，是在服务器端处理的。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>LESS和Sass中的变量的唯一区别就是，LESS使用<code>@</code>，而Sass使用<code>$</code>。同时还有一些作用域上的差别。</p><h4 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h4><p>Less没有输出设置，Sass提供四种输出选项：nested, compact, compressed 和 expanded。默认为nested：</p><ul><li>nested：嵌套缩进的css代码</li><li>expanded：展开的多行css代码</li><li>compact：简洁格式的css代码</li><li>compressed：压缩后的css代码</li></ul><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>Sass支持条件语句，可以使用<code>if{}else{}</code>，<code>for{}</code>循环等等。而Less不支持。</p><h4 id="外部文件引用"><a href="#外部文件引用" class="headerlink" title="外部文件引用"></a>外部文件引用</h4><p>scss引用的外部文件命名必须以_开头, 文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件。Less引用外部文件和css中的@import没什么差异。</p><h4 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h4><p>Sass有工具库Compass，Sass和Compass的关系有点像Javascript和jQuery的关系，Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。</p><p>Less有UI组件库Bootstrap，Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</p><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><h4 id="文件后缀名"><a href="#文件后缀名" class="headerlink" title="文件后缀名"></a>文件后缀名</h4><p>sass有两种后缀名文件：一种后缀名为<code>.sass</code>，不使用大括号和分号；另一种是<code>.scss</code>文件，这种和css文件格式差不多，使用大括号和分号。建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>sass的导入(@import)规则和CSS的有所不同，编译时会将<code>@import</code>的scss文件合并进来只生成一个CSS文件。但是如果在sass文件中导入css文件如<code>@import 'reset.css'</code>，那效果跟普通CSS导入样式文件一样，导入的css文件不会合并到编译后的文件中，而是以@import方式存在。</p><p>所有的sass导入文件都可以忽略后缀名<code>.scss</code>。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成<code>@import "mixin"</code>。</p><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>sass的变量必须是<code>$</code>开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开，如果值后面加上<code>!default</code>则表示默认值。</p><ul><li><p>普通变量：定义之后可以在全局范围内使用。</p></li><li><p>默认变量：sass的默认变量仅需要在值后面加上<code>!default</code>即可。sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。</p></li><li><p>特殊变量：一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以<code>#{$variables}</code>形式使用。</p></li><li><p>多值变量：多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。</p><ul><li>List：list数据可通过空格，逗号或小括号分隔多个值，可用<code>nth($var,$index)</code>取值。关于list数据操作还有很多其他函数如<code>length($list)</code>，<code>join($list1,$list2,[$separator])</code>，<code>append($list,$value,[$separator])</code>等。</li><li>Map：map数据以key和value成对出现，其中value又可以是list。格式为：<code>$map: (key1: value1, key2: value2, key3: value3)</code>。可通过<code>map-get($map,$key)</code>取值。关于map数据还有很多其他函数如<code>map-merge($map1,$map2)</code>，<code>map-keys($map)</code>，<code>map-values($map)</code>等。</li></ul></li><li><p>全局变量：在变量值后面加上<code>!global</code>即为全局变量。</p></li><li><p>目前变量机制：在选择器中声明的变量会覆盖外面全局声明的变量。</p></li></ul><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>sass的嵌套包括两种：一种是选择器的嵌套；另一种是属性的嵌套。我们一般说起或用到的都是选择器的嵌套。</p><ul><li><p>选择器嵌套：指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性。在选择器嵌套中，可以使用&amp;表示父元素选择器。</p></li><li><p>属性嵌套：所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。</p></li></ul><h4 id="at-root"><a href="#at-root" class="headerlink" title="@at-root"></a>@at-root</h4><p>用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。</p><p>默认<code>@at-root</code>只会跳出选择器嵌套，而不能跳出<code>@media</code>或<code>@support</code>，如果要跳出这两种，则需使用<code>@at-root (without: media)</code>，<code>@at-root (without: support)</code>。这个语法的关键词有四个：all（表示所有），rule（表示常规css），media（表示media），support（表示support，因为@support目前还无法广泛使用，所以在此不表）。我们默认的<code>@at-root</code>其实就是<code>@at-root (without:rule)</code>。</p><h4 id="混合-mixin"><a href="#混合-mixin" class="headerlink" title="混合(mixin)"></a>混合(mixin)</h4><p>sass中使用@mixin声明混合，可以传递参数，参数名以<code>$</code>符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的<code>@mixin</code>通过<code>@include</code>来调用。</p><ul><li><p>多个参数mixin：调用时可直接传入值，如<code>@include</code>传入参数的个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。建议传递参数的用<code>@mixin</code>，而非传递参数类的使用下面的继承%。</p></li><li><p>多组值参数mixin：如果一个参数可以有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点表示，如$variables…。</p></li><li><p>@content：<code>@content</code>在sass3.2.0中引入，可以用来解决css3的@media等带来的问题。它可以使@mixin接受一整块样式，接受的样式从@content开始。</p></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>sass中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词<code>@extend</code>，后面紧跟需要继承的选择器。</p><p>占位选择器<code>%</code>：这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了<code>@extend</code>去继承相应的样式，都会解析出来所有的样式。占位选择器以<code>%</code>标识定义，通过<code>@extend</code>调用。<br>ps：在<code>@media</code>中暂时不能@extend @media外的代码片段，以后将会可以。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>sass定义了很多函数可供使用，当然也可以自己定义函数，以<code>@fuction</code>开始。实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以<code>lighten</code>减淡和<code>darken</code>加深为最，其调用方法为lighten($color,$amount)和darken($color,$amount)，它们的第一个参数都是颜色值，第二个参数都是百分比。</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。</p><h4 id="条件判断及循环"><a href="#条件判断及循环" class="headerlink" title="条件判断及循环"></a>条件判断及循环</h4><ol><li><p><code>@if</code>判断，可一个条件单独使用，也可以和<code>@else</code>结合多条件使用；<br>三目判断，语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值；</p></li><li><p>for循环：for循环有两种形式，分别为：@for $var from<start>through<end>和@for $var from<start>to<end>。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数；</end></start></end></start></p></li><li><p><code>@each</code>循环：语法为：@each $var in &lt;\list or map&gt;。其中<code>$var</code>表示变量，而list和map表示list类型数据和map类型数据。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3cplus.com/css/an-introduction-to-less-and-comparison-to-sass.html" target="_blank" rel="noopener">https://www.w3cplus.com/css/an-introduction-to-less-and-comparison-to-sass.html</a></p><p><a href="https://www.cnblogs.com/coder-dumeng/p/4962223.html" target="_blank" rel="noopener">https://www.cnblogs.com/coder-dumeng/p/4962223.html</a></p><p><a href="https://www.w3cplus.com/sassguide/syntax.html" target="_blank" rel="noopener">https://www.w3cplus.com/sassguide/syntax.html</a></p>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Less</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter中State的生命周期</title>
    <url>/2019/08/30/flutter%E4%B8%ADState%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="State-的生命周期"><a href="#State-的生命周期" class="headerlink" title="State 的生命周期"></a>State 的生命周期</h2><p>StatefulWidget中的State的生命周期如下：</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f0af0a1b78bef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="State Tree"></p><h4 id="createState"><a href="#createState" class="headerlink" title="createState"></a>createState</h4><p>创建一个State。</p><h4 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h4><p>当插入渲染树的时候调用，这个函数在生命周期中只调用一次，可以进行初始化操作。</p><h4 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h4><p>在 initState() 调用结束后，这个函数会被调用。</p><p>在didChangeDependencies中，可以跨组件拿到数据。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>在这里构建视图。</p><h4 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget"></a>didUpdateWidget</h4><p>当组件的状态改变的时候就会调用didUpdateWidget。这个函数调用后，会调用 build()。</p><p>实际上这里flutter框架会创建一个新的Widget,绑定本State，并在这个函数中传递老的Widget。这个函数一般用于比较新、老Widget，看看哪些属性改变了，并对State做一些调整。</p><p>另外如果某些 Widget 上涉及到 controller 的变更，要么一定要在这个回调方法中移除旧的 controller 并创建新的 controller 监听。</p><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>可以手动调用这个函数更新视图，调用这个之后会触发didUpdateWidget()。</p><h4 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate"></a>deactivate</h4><p>当 State 被暂时从视图树中移除时，会调用这个函数。</p><p>页面切换时，也会调用它，因为此时 State 在视图树中的位置发生了变化，需要先暂时移除后添加。</p><p>PS: 重写的时候必须要调用 super.deactivate()。</p><h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h4><p>当State被销毁时调用，可以在这里移除监听释放资源。在调用这个函数之前，总会先调用 deactivate()。</p><p>PS: 重写的时候必须要调用 super.dispose()。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ca81c80e51d4509f8232e9b" target="_blank" rel="noopener">Flutter：界面刷新和生命周期</a></p>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>适合新手看的webpack安装和使用教程</title>
    <url>/2020/03/12/webpack%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>现在前端开发越来越偏向模块化，我们的项目也逐渐转向脚手架搭建。这其中，webpack的力量是巨大的，之前因为不了解webpack的某些配置所以在项目中也耽搁了一些时间，因此我觉得很有必要深入了解下webpack。之后需要自己尝试手动搭建项目工程，才能真正理解脚手架的原理。</p><a id="more"></a><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>官方的话来说，Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p>接下来让我们安装并初步配置下webpack吧~</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装，安装成功之后可以在全局使用<code>webpack</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line">npm install -g webpack-cli</span><br></pre></td></tr></table></figure><p>全局安装失败可能是网络的原因，可以使用淘宝镜像安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></table></figure><h2 id="栗子初体验"><a href="#栗子初体验" class="headerlink" title="栗子初体验"></a>栗子初体验</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>新建一个文件夹<code>weproject</code>并初始化项目：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd weproject</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p><code>npm init</code>会自动创建一个<code>package.json</code>文件，这个文件存放着当前项目的相关信息。</p><h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><p>在项目中安装webpack：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure><h4 id="构建目录"><a href="#构建目录" class="headerlink" title="构建目录"></a>构建目录</h4><p>新建文件夹<code>src</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir src</span><br></pre></td></tr></table></figure><p>在src文件夹中新建一个<code>index.js</code>。该文件是webpack的入口文件。webpack打包后会自动生成一个dist文件夹，默认生成构建文件<code>main.js</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//index.js</span><br><span class="line">document.write(&quot;I&apos;m index.js&quot;)</span><br></pre></td></tr></table></figure><p>在src文件夹中新建一个新建静态页面index.html，方便之后查看效果：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../dist/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>webpack4是可以不用手动配置（webpack会提供一套默认配置），但如果需要自定义配置，我们可以新建一个webpack的配置文件<code>webpack.config.js</code>，通过配置文件可以告诉webpack需要做些什么。</p><p>如下，在该文件中配置了入口文件和输出文件的路径：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,  <span class="comment">//入口文件</span></span><br><span class="line">  output: &#123; <span class="comment">//打包出口文件</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'./main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在的目录是这样的：</p><h4 id="执行webpack"><a href="#执行webpack" class="headerlink" title="执行webpack"></a>执行webpack</h4><p>在文件夹中执行命令<code>webpack</code>可以看到打包后的js文件在自动生成的dist文件夹中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack //或者 webpack --mode development</span><br></pre></td></tr></table></figure><p>在浏览器打开index.html可以查看效果，说明webpack把src&#x2F;index.js文件打包成dist&#x2F;main.js了。</p><h4 id="修改执行命令"><a href="#修改执行命令" class="headerlink" title="修改执行命令"></a>修改执行命令</h4><p>只需在package.json的<code>scripts</code>中加入:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dev":"webpack",</span><br><span class="line">"build":"webpack --mode production"</span><br></pre></td></tr></table></figure><p>就可以用<code>npm run dev</code>代替<code>webpack</code>，用<code>npm run build</code>代替<code>webpack --mode production</code>了。</p><h4 id="新建模块"><a href="#新建模块" class="headerlink" title="新建模块"></a>新建模块</h4><p>新建一个module.js：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"I'm module.js"</span></span><br></pre></td></tr></table></figure><p>在index.js中引用module.js：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> myModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">alert(myModule)</span><br></pre></td></tr></table></figure><p>重新执行<code>npm run dev</code>打开页面可以看到页面变化。webpack会分析入口文件，并解析包含依赖关系的文件，把他们都打包到main.js中。</p><p>到这里我们就初步了解了webpack的安装和使用啦，不过如果要实现更多自定义功能的话，我们还需要了解webpack的几个核心概念。</p><h2 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h2><p>webpack的核心有以下几点：</p><ol><li>Entry：入口</li><li>Output：出口</li><li>Loader：加载器</li><li>Plugins：插件</li><li>Mode：模式</li></ol><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口文件，entry可以是字符串（单入口），可以是数组或对象（多入口），如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      <span class="string">'./src/index.js'</span>,</span><br><span class="line">      <span class="string">'./src/index2.js'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack会解析多个入口文件的依赖后进行打包。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出文件，webpack默认创建的输出内容就是 .&#x2F;dist&#x2F;main.js。</p><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>表示生成文件的根目录，需要传入一个绝对路径。path参数和后面的filename参数共同组成入口文件的完整路径。</p><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>表示一个URL路径（指向生成文件的根目录），用于生成css&#x2F;js&#x2F;图片&#x2F;字体文件等资源的路径。 publicPath参数跟path参数的区别是：path参数其实是针对本地文件系统的，而publicPath则针对的是浏览器，因此，publicPath既可以是一个相对路径，也可以是一个绝对路径。</p><h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>表示如何命名生成出来的入口文件</p><h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>chunkFilename参数与filename参数类似，都是用来定义生成文件的命名方式的，只不过，chunkFilename参数指定的是除入口文件外的chunk（这些chunk通常是由于webpack对代码的优化所形成的，比如因应实际运行的情况来异步加载）的命名。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件（如css，图片，字体等），就需要使用 loader 进行转换。loader 将所有类型的文件，转换为应用程序的依赖可以直接引用的模块。</p><p>Loader 可以在<code>require()</code>引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用。</p><h4 id="打包css"><a href="#打包css" class="headerlink" title="打包css"></a>打包css</h4><p>新建一个文件style.css：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">background</span>: <span class="number">#fc9</span>; &#125;</span><br></pre></td></tr></table></figure><p>加载css需要安装以下loader：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader  --save-dev</span><br></pre></td></tr></table></figure><p>修改<code>webpack.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="built_in">module</span>:&#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;</span><br><span class="line">				test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				use: [<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.js中引用css文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./style.css'</span>)</span><br></pre></td></tr></table></figure><p>重新执行打包，打开页面就可以看到背景颜色了。</p><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><p>我们添加图片在项目中后（我的图片统一放在项目的img文件夹下），可以在style.css中继续补充：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'../img/bg.jpg'</span>) no-repeat;</span><br><span class="line">	<span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.html中添加一个div：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载图片需要安装以下loader：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install url-loader  --save-dev</span><br></pre></td></tr></table></figure><p>修改<code>webpack.config.js</code>，在<code>module.rules</code>中加入配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">	&#123;</span><br><span class="line">		test: /\.(jpg|png|gif)$/,</span><br><span class="line">		loader: &apos;url-loader&apos;</span><br><span class="line">	&#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>重新执行打包就可以看到效果了。</p><h4 id="处理字体"><a href="#处理字体" class="headerlink" title="处理字体"></a>处理字体</h4><p>处理字体和图片差不多，首先我把下载的字体文件放在新建的<code>icon</code>文件夹，如下图：<br>处理字体文件需要引入file-loader：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install file-loader  --save-dev</span><br></pre></td></tr></table></figure><p>修改<code>webpack.config.js</code>，在<code>module.rules</code>中加入配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">	&#123;</span><br><span class="line">		// exclude排除资源</span><br><span class="line">		exclude: /\.(css|js|html|less|json|jpg|png|gif)$/,</span><br><span class="line">		loader: &apos;file-loader&apos;,</span><br><span class="line">		options: &#123;</span><br><span class="line">			name:&apos;[hash:10].[ext]&apos;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>在入口文件引入<code>iconfont.css</code>, 并index.html中使用iconfont：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont icon-jia"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新执行打包就可以看到效果了。</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>插件目的在于解决 loader无法实现的其他事。插件接口功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要<code>require()</code>它，然后把它添加到 plugins 数组中。</p><h4 id="自动构建html"><a href="#自动构建html" class="headerlink" title="自动构建html"></a>自动构建html</h4><p>webpack支持自动创建html文件，首先得安装插件<code>html-webpack-plugin</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>然后在配置文件<code>webpack.config.js</code>中引用并调用该插件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	plugins:[</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令<code>webpack</code>会自动创建相应的html和js文件，并自动引用相应的静态资源文件。</p><p>如果需要自定义html路径，可以修改HtmlWebpackPlugin的参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">	template: &apos;./src/index.html&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="清理dist文件夹"><a href="#清理dist文件夹" class="headerlink" title="清理dist文件夹"></a>清理dist文件夹</h4><p>每次打包之后都会生成dist文件夹，而生成的文件夹不会清理掉之前遗留的文件，会造成不必要的资源浪费。因此我们打包之前最好删除之前的dist文件夹，或者配置自动清除dist文件夹的插件<code>clean-webpack-plugin</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure><p>然后在配置文件<code>webpack.config.js</code>中引用并调用该插件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	plugins:[</span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">			cleanAfterEveryBuildPatterns: [<span class="string">"dist"</span>],</span><br><span class="line">		&#125;),</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们下次打包的时候就会自动清理上次打包的文件啦~</p>]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的Vue路由指南</title>
    <url>/2021/08/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue%E8%B7%AF%E7%94%B1%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>1.hash模式<br>使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p><ul><li>原理<br>基于浏览器的hashchange事件，当地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。<a id="more"></a></li><li>优点<br>hash值不会被包含在Http请求中, 因此hash值改变不会重新加载页面；hash改变会触发hashchange事件, 能控制浏览器的前进后退；兼容性好；</li><li>缺点<br>地址栏中携带#；hash有体积限制，只可添加短字符串；当设置的新值必须与原来不一样才会触发hashchange事件；</li></ul><p>2.history模式<br>依赖 HTML5 History API 和服务器配置。</p><ul><li>原理<br>基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。</li><li>优点<br>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；浏览器的进后退能触发浏览器的popstate事件，获取window.location.pathname来控制页面的变化；</li><li>缺点<br>URL的改变属于http请求，借助history.pushState实现页面的无刷新跳转，因此会重新请求服务器，所以前端的 URL 必须和实际向后端发起请求的 URL 一致，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面；兼容性差，特定浏览器支持；</li><li>后端配置例子<br><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">HTML5 History 模式</a></li></ul><p>3.abstract<br>支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</p><h3 id="响应路由"><a href="#响应路由" class="headerlink" title="响应路由"></a>响应路由</h3><p>当使用路由参数时，例如从 &#x2F;user&#x2F;id1 导航到 &#x2F;user&#x2F;id2，原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。<br>此时可以监听路由的变化：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导航守卫（beforeRouteUpdate）"><a href="#导航守卫（beforeRouteUpdate）" class="headerlink" title="导航守卫（beforeRouteUpdate）"></a>导航守卫（beforeRouteUpdate）</h3><p>1.全局前置守卫</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置钩子</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.全局解析守卫<br>可以使用router.beforeResolve注册一个全局守卫，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p><p>3.路由独享的守卫</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.组件内的守卫</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.完整的导航解析流程<br>失活组件beforeRouteLeave -&gt; beforeEach -&gt; 重用组件beforeRouteUpdate -&gt; 路由beforeEnter -&gt; 激活组件beforeRouteEnter -&gt; beforeResolve -&gt; afterEach -&gt; DOM更新</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://router.vuejs.org/zh/guide/" target="_blank" rel="noopener">Vue Router</a></p><p><a href="https://juejin.cn/post/6867875626611654663" target="_blank" rel="noopener">原来这就是hash模式和history模式的区别</a></p>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>写给自己的前端面试指南</title>
    <url>/2022/04/19/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>分类收集整理一些前端面试要点。</p><a id="more"></a><h2 id="熟练掌握JavaScript"><a href="#熟练掌握JavaScript" class="headerlink" title="熟练掌握JavaScript"></a>熟练掌握JavaScript</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul><li><p>全局环境下的this：指向全局对象window</p></li><li><p>函数内的this：</p><ul><li>默认情况：非严格模式下this指向全局对象, 严格模式下this会指向undefined</li><li>箭头函数：箭头函数本身没有 this， this的指向由外层作用域决定的</li><li>构造函数：构造函数中的this是指向实例</li><li>通过call()、apply()或者bind()直接指定this的绑定对象，bind()是创建一个新的函数，需要手动调用才会执行</li></ul></li><li><p>对象中的this：</p><ul><li>函数的定义位置不影响其this指向，this指向只和调用函数的对象有关(this 永远指向最后<code>调用</code>它的那个对象)</li><li>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象</li></ul></li></ul><p><a href="https://juejin.cn/post/6844904083707396109" target="_blank" rel="noopener">this面试题</a></p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数内部的this是词法作用域（本身没有this），由上下文确定。在以下需要用this的场景尽量不使用：</p><ul><li>定义对象的方法</li><li>定义原型方法</li><li>构造函数使用箭头函数</li><li>作为事件的回调函数</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p><code>__proto__</code>和<code>constructor</code>属性是对象所独有的。<br><code>__proto__</code>属性（即<code>[[prototype]]</code>）是一个对象指向它的原型对象的指针。当访问一个对象的属性，如果找不到对象的该属性，就会沿着<code>__proto__</code>指向的父对象找，如果还没找到就会继续沿着<code>__proto__</code>指向找，直到找到原型链的终点<code>null</code>，这种就是<code>原型链</code>。</p></blockquote><blockquote><p><code>prototype</code>是从函数指向一个对象（该(构造)函数所创建实例的原型对象），可以让所有实例都共享公用的属性和方法。<code>prototype</code>属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p></blockquote><blockquote><p><code>constructor</code>是指向该对象的构造函数。可以理解为所有函数(对象)都由<code>Function</code>构造而来，所以<code>constructor</code>的终点就是<code>Function</code>。</p></blockquote><p><a href="https://blog.51cto.com/u_14582976/2826828" target="_blank" rel="noopener">搞懂JS中的prototype、__proto__与constructor</a></p><h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p>操作：</p><ol><li>创建一个空的javascript对象；</li><li>为创建的对象添加<code>__proto__</code>属性，该属性指向构造函数的原型对象prototype；</li><li>将创建的对象作为构造函数中this的上下文（new关键字修改了这个this指针）；</li><li>如果函数没有返回对象，则返回这个this（这也是为什么构造函数通常不写return语句）；实际上，只要构造函数return的不是对象，就会自动忽略。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>原型链继承、构造函数继承、原型链+借用构造函数的组合继承、class 继承<br><a href="https://segmentfault.com/a/1190000016708006" target="_blank" rel="noopener">JavaScript常见的六种继承方式</a></p><h3 id="promise和-async-x2F-await"><a href="#promise和-async-x2F-await" class="headerlink" title="promise和 async&#x2F;await"></a>promise和 async&#x2F;await</h3><p>Promise解决了异步嵌套的怪圈，异步请求方法用链式表达更加清晰，但是如果有大量的异步请求的时候，流程复杂的情况下，会发现充满了屏幕的then，看起来非常吃力，而ES7的Async&#x2F;Await的出现就是为了解决这种复杂的情况。</p><p>错误捕捉方式：promise 使用.catch；async&#x2F;await 可以.then.catch，也可以 try&#x2F;catch</p><p>调用方式：promsie 连续调用，链式调用；async&#x2F;await 简洁易懂，异步操作同步化</p><p><a href="https://segmentfault.com/a/1190000016788484" target="_blank" rel="noopener">异步Promise及Async&#x2F;Await可能最完整入门攻略</a></p><h4 id="promise的3种状态"><a href="#promise的3种状态" class="headerlink" title="promise的3种状态"></a>promise的3种状态</h4><p>pending、resolved、rejected</p><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>javascript是一门单线程语言，执行事件是先同步再异步，异步中先微任务，再宏任务。event loop它最主要是分三部分：主线程、宏任务（macro-task）、微任务（micro-task）。</p><ul><li>macro-task(宏任务)：setTimeout，setInterval</li><li>micro-task(微任务)：Promise.then&#x2F;catch，process.nextTick</li></ul><p>执行流程：主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查micro-task队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有micro-task。然后再进入下一个循环去任务队列中取下一个任务执行。</p><p><a href="https://segmentfault.com/a/1190000038928521" target="_blank" rel="noopener">js事件循环机制event-loop</a></p><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p><a href="https://blog.csdn.net/destinytaoer/article/details/82114848" target="_blank" rel="noopener">JS 作用域和作用域链</a></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><a href="https://blog.csdn.net/happy_kx/article/details/124330489" target="_blank" rel="noopener">闭包的作用</a></p><h3 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h3><p>设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等。如观察者模式、发布订阅模式<br><a href="https://segmentfault.com/a/1190000007899742" target="_blank" rel="noopener">JavaScript设计模式</a></p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md" target="_blank" rel="noopener">JavaScript 算法与数据结构</a></p><h2 id="进击的CSS"><a href="#进击的CSS" class="headerlink" title="进击的CSS"></a>进击的CSS</h2><h3 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h3><p>盒模型包括包括margin、border、padding、content</p><ul><li>标准盒模型：content 部分不包含其他部分</li><li>IE盒模型：content 部分包含了 border 和 pading</li></ul><p><a href="https://segmentfault.com/a/1190000015235886" target="_blank" rel="noopener">面试官：谈谈你对 CSS 盒模型的认识?</a></p><h4 id="文档流和BFC"><a href="#文档流和BFC" class="headerlink" title="文档流和BFC"></a>文档流和BFC</h4><p>文档流：将窗体自上而下分成一行行，并在每一行中按从左到右的顺序来排放元素，这个我们称之为文档流。</p><p>非文档流(脱离文档流):也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。</p><p><code>BFC(Block formatting context)</code>: 称为块级格式化上下文，是CSS中的一种渲染机制。它决定了块级元素如何对它的子元素内容进行布局，以及与子元素同级别的兄弟元素的关系和相互作用。</p><p>BFC 的原理：</p><ul><li>BFC 这个元素的垂直的边距会发生重叠</li><li>BFC 的区域不会与浮动元素的 float 重叠</li><li>独立的容器，内外元素互不影响</li><li>计算 BFC 高度，浮动元素也参与计算</li></ul><h3 id="flex和grid"><a href="#flex和grid" class="headerlink" title="flex和grid"></a>flex和grid</h3><p>flex 布局和 Grid 布局有实质的区别，那就是 flex 布局是一维布局，Grid 布局是二维布局。Flex布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局，Grid 布局则是将容器划分成“行”和“列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局，Grid布局远比 Flex布局强大。</p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex布局详解</a><br><a href="https://blog.csdn.net/leilei__66/article/details/122360901https://blog.csdn.net/leilei__66/article/details/122360901" target="_blank" rel="noopener">grid布局</a></p><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p><a href="https://www.cnblogs.com/coco1s/p/15796478.html" target="_blank" rel="noopener">深入浅出 CSS 动画</a></p><h2 id="必备的HTML"><a href="#必备的HTML" class="headerlink" title="必备的HTML"></a>必备的HTML</h2><h3 id="history-api"><a href="#history-api" class="headerlink" title="history api"></a>history api</h3><p>window 对象通过 history 对象提供了对浏览器的会话历史的访问，提供了对history栈中内容的操作。可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址，动态修改页面上所显示资源。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在history中向后跳转：</span></span><br><span class="line"><span class="built_in">window</span>.history.back()</span><br><span class="line"><span class="built_in">window</span>.history.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向前跳转：</span></span><br><span class="line"><span class="built_in">window</span>.history.forward()</span><br><span class="line"><span class="built_in">window</span>.history.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//历史记录中页面总数</span></span><br><span class="line">history.length</span><br></pre></td></tr></table></figure><p>HTML5 引入了<code>history.pushState()</code>和<code>history.replaceState()</code>方法，它们分别可以添加和修改历史记录条目。</p><ul><li>history.pushState(state, title, url): 添加一条历史记录，不刷新页面</li><li>history.replaceState(state, title, url): 替换当前的历史记录，不刷新页面</li><li>popstate 事件：历史记录发生改变时触发，调用history.pushState()或者history.replaceState()不会触发popstate事件</li><li>hashchange 事件：当页面的hash值改变的时候触发，常用于构建单页面应用</li></ul><h2 id="主流的前端框架"><a href="#主流的前端框架" class="headerlink" title="主流的前端框架"></a>主流的前端框架</h2><p><a href="/2021/05/27/%E5%87%A0%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">几大框架知识点梳理</a></p><h2 id="模块化和工程化"><a href="#模块化和工程化" class="headerlink" title="模块化和工程化"></a>模块化和工程化</h2><p><a href="https://mp.weixin.qq.com/s/Zvor5SBSy4RYtj_zmzhuAg" target="_blank" rel="noopener">结合代码实践，全面学习前端工程化</a></p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li><p>CommonJs (典型代表：node.js 早期)：用于服务端</p><ul><li>都运行在模块作用域，不会污染全局作用域</li><li>同步加载的，即只有加载完成，才能执行后面的操作</li><li>首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li>require 返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li></ul></li><li><p>AMD (典型代表：require.js):异步模块定义<br>所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行<br>require</p></li><li><p>CMD (典型代表：sea.js)</p></li><li><p>ES6 的 Module：import&#x2F;export</p><ul><li>CommonJS 和 AMD 模块，都只能在运行时确定这些东西</li><li>ES6 设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li><li>import()允许您仅在需要时动态加载模块，而不必预先加载所有模块</li></ul></li></ul><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>脚手架的出现就是为减少重复性工作而引入的命令行工具，实现脚手架的核心思想就是自动化思维。</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p><a href="/2020/03/12/webpack%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/">webpack安装使用</a></p><h4 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h4><p><a href="https://juejin.cn/post/6844904071736852487" target="_blank" rel="noopener">玩转 webpack，使你的打包速度提升 90%</a></p><p><a href="https://segmentfault.com/a/1190000018493260" target="_blank" rel="noopener">Webpack构建速度优化</a></p><h4 id="Webpack构建流程"><a href="#Webpack构建流程" class="headerlink" title="Webpack构建流程"></a>Webpack构建流程</h4><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，创建Compiler对象并开始解析项目</li><li>编译：从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件；整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><h4 id="Loader和Plugin的区别"><a href="#Loader和Plugin的区别" class="headerlink" title="Loader和Plugin的区别"></a>Loader和Plugin的区别</h4><p>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到。</p><p>Plugin 就是插件，用于在webpack打包编译过程里，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。</p><h4 id="热更新（HMR）原理"><a href="#热更新（HMR）原理" class="headerlink" title="热更新（HMR）原理"></a>热更新（HMR）原理</h4><p>可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。<br><a href="https://cloud.tencent.com/developer/article/1621751" target="_blank" rel="noopener">webpack 热更新实现原理</a></p><h3 id="rollup适用的场景"><a href="#rollup适用的场景" class="headerlink" title="rollup适用的场景"></a>rollup适用的场景</h3><p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码。</p><p>Rollup偏向应用于js库，webpack偏向应用于前端工程，UI库；如果你的应用场景中只是js代码，希望做ES转换，模块解析，可以使用Rollup。如果你的场景中涉及到css、html，涉及到复杂的代码拆分合并，建议使用webpack。</p><h3 id="脚手架-1"><a href="#脚手架-1" class="headerlink" title="脚手架"></a>脚手架</h3><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h3><p>Cookie、localStorage、sessionStorage、IndexedDB</p><p><a href="/2020/06/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/">常见的浏览器本地存储</a></p><h3 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h3><p><a href="https://segmentfault.com/a/1190000022633988" target="_blank" rel="noopener">前端都该懂的浏览器工作原理</a></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p><code>http</code>：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</p><p><code>https</code>：是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><p><a href="https://blog.csdn.net/weixin_43484007/article/details/125167585" target="_blank" rel="noopener">Http1.0、1.1、2.0、3.0的区别</a></p><p><a href="https://blog.csdn.net/jj16165858/article/details/124504657" target="_blank" rel="noopener">HTTP协议经典面试题</a></p><h3 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h3><p><a href="https://blog.csdn.net/jianchibuxie0/article/details/108296223" target="_blank" rel="noopener">强缓存和协商缓存</a></p><p><a href="https://www.cnblogs.com/tiwlin/archive/2011/06/10/2077193.html" target="_blank" rel="noopener">Etag详解</a></p><h3 id="CSRF和XSS、SQL-注入攻击"><a href="#CSRF和XSS、SQL-注入攻击" class="headerlink" title="CSRF和XSS、SQL 注入攻击"></a>CSRF和XSS、SQL 注入攻击</h3><p><code>CSRF</code>：跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><code>XSS</code>：跨站脚本攻击，攻击者通过“注入”，在网页中插入恶意代码，从而被浏览器执行所造成的一种攻击方式。</p><p><a href="https://www.cnblogs.com/zhouyyBlog/p/14505961.html" target="_blank" rel="noopener">xss和csrf</a></p><p><a href="https://blog.csdn.net/a873051927/article/details/115942247" target="_blank" rel="noopener">防止token泄露</a></p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p><code>Websocket</code>是 HTML5 新增的基于TCP的网络通信协议。</p><blockquote><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><blockquote><p>它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。</p></blockquote><p>优点：</p><ul><li>较少的控制开销</li><li>更强的实时性</li><li>保持连接状态</li><li>更好的二进制支持、可以支持扩展、更好的压缩效果</li></ul><p><a href="https://blog.csdn.net/sinat_36422236/article/details/85051547" target="_blank" rel="noopener">websocket深入浅出</a></p><p><a href="https://blog.csdn.net/qq_54773998/article/details/123863493" target="_blank" rel="noopener">WebSocket</a></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="canvas常用API"><a href="#canvas常用API" class="headerlink" title="canvas常用API"></a>canvas常用API</h3><p>Canvas API 提供了一个通过JavaScript和HTML的<code>&lt;canvas&gt;</code>元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。<br><a href="https://juejin.cn/post/6844904104121073678" target="_blank" rel="noopener">Canvas常用API</a><br><a href="https://m.yisu.com/zixun/408468.html" target="_blank" rel="noopener">html5中canvas的绘图API</a></p><h3 id="webgl和threejs"><a href="#webgl和threejs" class="headerlink" title="webgl和threejs"></a>webgl和threejs</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><p>TypeScript 是基于 JavaScript 创造的强类型编程语言，可以进行任意程度的扩展。</p><p>优点：</p><ul><li>良好的类型定义和对 ES6 的支持</li><li>增长了代码的可读性和可维护性</li><li>类型错误会在编译过程中被编译器发现，便于发现BUG</li><li>代码可预测性：声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</li><li>便于重构</li></ul><p>缺点：</p><ul><li>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。所以还是会有些类型问题（如any）</li><li>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。</li><li>增加开发成本：如类型定义和接口声明<br><a href="https://juejin.cn/post/6988763249982308382" target="_blank" rel="noopener">「面试题」TypeScript</a></li></ul><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><p><a href="https://blog.51cto.com/u_13225813/3118537" target="_blank" rel="noopener">NodeJS面试题</a></p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><h4 id="uniapp"><a href="#uniapp" class="headerlink" title="uniapp"></a>uniapp</h4><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>Flutter 和 React Native 不同主要在于 Flutter UI是直接通过 skia 渲染的 ，而 React Native 是将 js 中的控件转化为原生控件，通过原生去渲染的。<br><a href="https://juejin.cn/post/6864816494749057038" target="_blank" rel="noopener">Flutter面试指南</a></p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><p>资源打包分析：webpack-bundle-analyzer</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line"><span class="comment">// webpack.config.js 文件</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">          analyzerMode: <span class="string">'server'</span>,</span><br><span class="line">          analyzerHost: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">          analyzerPort: <span class="number">8889</span>,</span><br><span class="line">          reportFilename: <span class="string">'report.html'</span>,</span><br><span class="line">          defaultSizes: <span class="string">'parsed'</span>,</span><br><span class="line">          openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">          generateStatsFile: <span class="literal">false</span>,</span><br><span class="line">          statsFilename: <span class="string">'stats.json'</span>,</span><br><span class="line">          statsOptions: <span class="literal">null</span>,</span><br><span class="line">          logLevel: <span class="string">'info'</span></span><br><span class="line">        &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"analyz"</span>: <span class="string">"NODE_ENV=production npm_config_report=true npm run build"</span></span><br></pre></td></tr></table></figure></li><li><p>Gzip压缩: Compression-webpack-plugin</p></li><li><p>JavaScript、Css、Html压缩：UglifyJS、webpack-parallel-uglify-plugin、terser-webpack-plugin、mini-css-extract-plugin</p></li></ul><p><a href="https://segmentfault.com/a/1190000022205291" target="_blank" rel="noopener">前端性能优化 24 条建议</a><br><a href="https://juejin.cn/post/6911472693405548557" target="_blank" rel="noopener">聊一聊前端性能优化</a></p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>几大框架知识点梳理</title>
    <url>/2021/05/27/%E5%87%A0%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="props-x2F-emit"><a href="#props-x2F-emit" class="headerlink" title="props&#x2F;$emit"></a>props&#x2F;$emit</h4><p>父组件通过props向下传递数据给子组件，子组件通过$emit发送事件给父组件发消息（传值）。</p><p>缺点：比较适合父子组件通信，在兄弟组件和跨级组件中使用会比较复杂</p><a id="more"></a><h4 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h4><p>通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙地实现了任何组件间的通信，包括父子、兄弟、跨级。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line">EventBus.$emit(eventName, data)</span><br><span class="line">EventBus.$on(eventName, data =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><p>缺点：比较适合兄弟组件和跨级组件通信，但事件太多会比较混乱不好管理</p><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>缺点：使用vuex组件传值需要把值存到全局仓库中，对于小型的项目，通信十分简单，这时使用 Vuex 反而会显得冗余和繁琐。</p><h4 id="attrs-x2F-listeners"><a href="#attrs-x2F-listeners" class="headerlink" title="$attrs&#x2F;$listeners"></a>$attrs&#x2F;$listeners</h4><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器（存放的是父组件中绑定的非原生事件）。它可以通过 v-on&#x3D;”$listeners” 传入内部组件。</li></ul><p>缺点：适用于特定的情况，比如父组件和孙子组件</p><h4 id="provide-x2F-inject"><a href="#provide-x2F-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h4><p>祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</p><p>provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p>缺点：provide 和 inject 绑定并不是可响应的。（如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。）它被设计是为组件库和高阶组件服务的，平常业务中的代码不建议使用。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</p><p>缺点：不太适合嵌套层级太多的时候使用。$refs 不是响应式的，只能拿到获取它的那一刻子组件实例的状态。</p><h4 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent &#x2F; $children"></a>$parent &#x2F; $children</h4><p>$parent 属性可以用来从一个子组件访问父组件的实例，$children 属性 可以获取当前实例的直接子组件。</p><p>缺点：如果使用 $parent 导致父组件数据变更后会破坏单项数据流，在绝大多数情况下，不推荐使用。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="/2019/04/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Vue生命周期</a></p><h3 id="路由（建议vue-router"><a href="#路由（建议vue-router" class="headerlink" title="路由（建议vue-router)"></a>路由（建议vue-router)</h3><p><a href="/2021/08/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue%E8%B7%AF%E7%94%B1%E6%8C%87%E5%8D%97/">Vue路由</a></p><h4 id="配置404"><a href="#配置404" class="headerlink" title="配置404"></a>配置404</h4><p>当使用通配符路由时，含有通配符的路由应该放在最后。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'*'</span>,    <span class="comment">//至于最底部</span></span><br><span class="line">  redirect: <span class="string">'/404'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态管理（Vuex"><a href="#状态管理（Vuex" class="headerlink" title="状态管理（Vuex)"></a>状态管理（Vuex)</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>定义了应用状态的数据结构，可以在这里设置默认的初始状态。</p><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</p><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p>唯一更改 store 中状态的方法，且必须是同步函数。</p><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.vue3对比vue2具有明显的性能提升</p><p>2.具有的composition API实现逻辑模块化和重用</p><p>3.支持TS</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1.原理上</p><p>Vue2实现双向数据绑定原理，是通过es5的 <code>Object.defineProperty</code>，根据具体的key去读取和修改。其中的setter方法来实现数据劫持的，getter实现数据的修改。因此无法监听属性的添加和删除，不能监听数组的变化等。</p><p>Vue3使用原生<code>Proxy</code> 替代 <code>Object.defineProperty</code>，Proxy可以理解成，在对象之前架设一层“拦截”，拦截了对象的get和set操作。Proxy可以直接监听对象而非属性，并返回一个新对象，具有更好的响应式支持。</p><p>详细可看<a href="/2019/04/23/%E5%AF%B9Vue%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">Vue2和Vue3原理区别</a></p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>1.setState 操作合并</p><ul><li>当第一个传入的参数是 object 数据类型它就会合并，类型调用了 Object.assgin</li><li>当参数类型是 function 数据类型时，不会合并</li></ul><p>2.setState 是否异步</p><ul><li>React 获得控制权的时候，它就是异步执行</li><li>当 React 丧失控制权的时候，它就是同步执行（setTimeout、Promise 等异步函数；自定义注册 DOM 事件等）</li></ul><h3 id="组件生命周期的方法-react-v17"><a href="#组件生命周期的方法-react-v17" class="headerlink" title="组件生命周期的方法(react v17)"></a>组件生命周期的方法(react v17)</h3><p>1.挂载</p><ul><li>constructor()</li><li>static getDerivedStateFromProps()</li><li>render()</li><li>componentDidMount()</li></ul><p>2.更新</p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ul><p>3.卸载</p><ul><li>componentWillUnmount()</li></ul><p>4.错误处理</p><ul><li>static getDerivedStateFromError()</li><li>componentDidCatch()</li></ul><h3 id="Redux、React-redux、Redux-中间件"><a href="#Redux、React-redux、Redux-中间件" class="headerlink" title="Redux、React-redux、Redux 中间件"></a>Redux、React-redux、Redux 中间件</h3><h3 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h3><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。</p></blockquote><p><a href="https://blog.csdn.net/xuewenjie0217/article/details/119112122" target="_blank" rel="noopener">react hook 详解及使用</a></p><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>应用生命周期</p><p>小程序从启动 -&gt; 运行 -&gt; 销毁的过程</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  <span class="comment">//小程序初始化完成时，执行此函数，全局只触发一次。可以做一些初始化的工作</span></span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//小程序启动，或从后台进入前台显示时触发</span></span><br><span class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//小程序从前台进入后台时触发</span></span><br><span class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//小程序发生脚本错误或 API 调用报错时触发</span></span><br><span class="line">  onError: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>页面生命周期</p><p>小程序中，每个页面的加载 -&gt; 渲染 -&gt; 销毁的过程</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">//监听页面加载，一个页面只调用1次</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//监听页面显示</span></span><br><span class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//监听页面初次渲染完成，一个页面只调用1次</span></span><br><span class="line">  onReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//监听页面隐藏</span></span><br><span class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//监听页面卸载，一个页面只调用1次</span></span><br><span class="line">  onUnload: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件的生命周期</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  <span class="comment">//监听组件创建</span></span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在组件完全初始化完毕、进入页面节点树后被触发</span></span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在组件离开页面节点树后被触发</span></span><br><span class="line">  detached: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在组件在视图层布局完成后执行</span></span><br><span class="line">  ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在组件实例被移动到节点树另一个位置时执行</span></span><br><span class="line">  moved: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//组件抛出错误时执行</span></span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><h3 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p>最后附上我去年画的思维脑图吧：</p><p><img src="/images/other/mindMap.png" alt="force"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">Vuex</a></p><p><a href="https://react.docschina.org/docs/react-component.html" target="_blank" rel="noopener">react</a></p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript笔记</title>
    <url>/2020/01/18/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h2><p>TypeScript 是 JavaScript 的类型的超集，它可以编译成 JavaScript。TypeScript是一门静态语言，新增了静态类型、类、模块、接口和类型注解，规避了一些类型上的低级错误，更适合应用于开发大型应用。</p><h2 id="全局安装-TypeScript"><a href="#全局安装-TypeScript" class="headerlink" title="全局安装 TypeScript"></a>全局安装 TypeScript</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="TypeScript-类型"><a href="#TypeScript-类型" class="headerlink" title="TypeScript 类型"></a>TypeScript 类型</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br></pre></td></tr></table></figure><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: string = <span class="string">'Tom'</span>;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数组的两种方式</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二，使用数组泛型</span></span><br><span class="line"><span class="keyword">let</span> newlist: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><h4 id="任意值-Any"><a href="#任意值-Any" class="headerlink" title="任意值(Any)"></a>任意值(Any)</h4><p>任意值（Any）用来表示允许赋值为任意类型。</p><p>在任意值上访问任何属性都是允许的，也允许调用任何方法，可以认为声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: any = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName);</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName.firstName);</span><br><span class="line"></span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型。</p><h4 id="空值（Void"><a href="#空值（Void" class="headerlink" title="空值（Void)"></a>空值（Void)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">'My name is Tom'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以用 void 表示没有任何返回值的函数。声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null。</p><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num: number = u;</span><br></pre></td></tr></table></figure><h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p>never类型表示的是那些永不存在的值的类型。</p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="string">"string"</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">false</span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">undefined</span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: string = <span class="string">'seven'</span>;</span><br></pre></td></tr></table></figure><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口的作用就是为一些类型命名和代码定义契约，进行类型检查。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">  color?: number; <span class="comment">//可选</span></span><br><span class="line">  readonly width: number; <span class="comment">//只读</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">config: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(config.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">config: LabelledValue</span>): </span>&#123;label: string; color: string; width: number&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newLabel = &#123;<span class="attr">label</span>: <span class="string">''</span>, <span class="attr">color</span>: <span class="string">"white"</span>, <span class="attr">width</span>: <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newLabel.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newLabel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = createLabel(&#123;<span class="attr">label</span>: <span class="string">'aaa'</span>, <span class="attr">color</span>: <span class="string">"black"</span>, <span class="attr">width</span>: <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><p>TypeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改:</t></t></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用类型断言重写</span></span><br><span class="line">a = ro <span class="keyword">as</span> number[];</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>新建一个文件夹<code>learn_ts</code>，在文件夹中新建<code>src</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd learn_ts</span><br><span class="line">mkdir src</span><br></pre></td></tr></table></figure><p>初始化文件夹：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>目录下自动生成了一个<code>package.json</code>文件和<code>tsconfig.json</code>文件。</p><p>tsconfig.json是TypeScript 的配置文件，其中包含了初始化的一些配置，之后我们也可以自定义一些配置。</p><h3 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h3><p>在src文件夹下新建一个index.ts文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure><p>编译ts文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc index.ts</span><br></pre></td></tr></table></figure><p>编译之后会在文件夹中生成一个同名的js文件。</p><blockquote><p>TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。</p></blockquote><p>TypeScript 编译的时候即使报错了，还是会生成编译结果。（如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/basic-types.html</a></p>]]></content>
      <categories>
        <category>笔记</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端高频面试题收录</title>
    <url>/2022/08/16/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h4 id="1-深拷贝和浅拷贝-递归调用死循环问题如何解决"><a href="#1-深拷贝和浅拷贝-递归调用死循环问题如何解决" class="headerlink" title="1. 深拷贝和浅拷贝(递归调用死循环问题如何解决)"></a>1. 深拷贝和浅拷贝(递归调用死循环问题如何解决)</h4><blockquote><p>基本类型–名值都存储在栈内存中。引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值</p></blockquote><p>基本类型赋值时，赋的是值，所以不存在深浅拷贝问题。</p><p>引用类型赋值时，只是将对象的引用复制了一份，浅拷贝就是新值和旧值变量指向同一个内存地址，当地址中的值改变时，他们都会同时变化。</p><p>深拷贝就是实现新旧值互不影响，拷贝的过程中，独立地开辟了一个空间，这个对象指向这个地址，与原来的对象互不干扰。深拷贝也被称为值拷贝。</p><a id="more"></a><p>对象实现深拷贝有<code>JSON.parse(JSON.stringify())</code>，<code>Object.assign()</code>。数组实现深拷贝有<code>slice</code>，<code>concat</code>。</p><blockquote><p>用扩展运算符对数组或者对象进行拷贝时，只能扩展和深拷贝第一层的值，对于第二层及其以后的值，扩展运算符将不能对其进行打散扩展，也不能对其进行深拷贝，即拷贝后和拷贝前第二层中的对象或者数组仍然引用的是同一个地址，其中一方改变，另一方也跟着改变。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现深拷贝</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理null或者undefined</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 处理日期类型</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="comment">// 处理正则类型</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 普通值或函数不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 对象进行深拷贝(解决循环引用)</span></span><br><span class="line">  <span class="keyword">if</span> (hash.get(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/echolun/p/16157161.html" target="_blank" rel="noopener">JS 从零手写一个深拷贝</a></p><h4 id="2-防抖和节流"><a href="#2-防抖和节流" class="headerlink" title="2. 防抖和节流"></a>2. 防抖和节流</h4><p><code>防抖</code>（debounce）是当事件被触发后，延迟n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时<code>（多次触发，只执行最后一次）</code>。</p><p>作用： 高频率触发的事件，在指定的单位时间内，只响应最后一次，如果在指定的时间内再次触发，则重新计算时间。</p><p>应用场景：按钮多次点击，resize 多次触发、搜索框输入查询等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;  <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      f(...args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>节流</code>（throttle），控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似<code>（规定时间内，只触发一次）</code>。</p><p>作用： 高频率触发的事件,在指定的单位时间内，只响应第一次。</p><p>应用场景：监听滚动事件，播放事件等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      f(...args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-async-x2F-await-和-Promise、JS事件循环机制"><a href="#3-async-x2F-await-和-Promise、JS事件循环机制" class="headerlink" title="3. async&#x2F;await 和 Promise、JS事件循环机制"></a>3. async&#x2F;await 和 Promise、JS事件循环机制</h4><p><a href="/2022/04/19/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/">写给自己的前端面试指南</a></p><h4 id="4-for-in-和-for-of"><a href="#4-for-in-和-for-of" class="headerlink" title="4. for in 和 for of"></a>4. for in 和 for of</h4><ul><li><p><code>for in</code>：主要用来遍历对象（for keys in obj）</p><p>遍历自身和继承的可枚举属性（延续原型链遍历出对象的原型属性）</p><p>有什么问题：要使用 hasOwnProperty 判断，只处理自身的，不处理继承的</p></li><li><p><code>for of</code>： ES6 新增的，遍历所有数据结构的统一的方法</p><p>只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for…of 循环遍历它的成员</p><p>包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串</p></li></ul><h4 id="5-高阶函数作用：柯里化-curry-；组合函数-compose-；管道函数-pipe"><a href="#5-高阶函数作用：柯里化-curry-；组合函数-compose-；管道函数-pipe" class="headerlink" title="5. 高阶函数作用：柯里化(curry)；组合函数(compose)；管道函数(pipe)"></a>5. 高阶函数作用：柯里化(curry)；组合函数(compose)；管道函数(pipe)</h4><h4 id="6-slice和splice的区别"><a href="#6-slice和splice的区别" class="headerlink" title="6. slice和splice的区别"></a>6. slice和splice的区别</h4><p>两者都是数组删除的方法</p><ol><li>splice改变原数组，slice不改变原数组。</li><li>slice会返回一个新的数组，可以用于截取数组</li><li>splice除了可以删除之外，还可以替换，添加数组</li><li>splice可传入3个参数，slice接受2个参数</li></ol><h4 id="7-substr和substring的区别"><a href="#7-substr和substring的区别" class="headerlink" title="7. substr和substring的区别"></a>7. substr和substring的区别</h4><p>两者的作用都是截取字符串的。</p><ul><li>substr是从起始索引号开始提取指定长度的字符串</li><li>substring是提取字符串中两个指定索引号之间的字符</li></ul><h4 id="let-const-var区别"><a href="#let-const-var区别" class="headerlink" title="let const var区别"></a>let const var区别</h4><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h4 id="1-vue-响应式原理"><a href="#1-vue-响应式原理" class="headerlink" title="1. vue 响应式原理"></a>1. vue 响应式原理</h4><p><a href="/2019/04/23/%E5%AF%B9Vue%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">Vue2和Vue3原理区别</a></p><h4 id="2-虚拟-dom-原理-和-diff-算法"><a href="#2-虚拟-dom-原理-和-diff-算法" class="headerlink" title="2. 虚拟 dom 原理 和 diff 算法"></a>2. 虚拟 dom 原理 和 diff 算法</h4><h4 id="3-vue-组件传值"><a href="#3-vue-组件传值" class="headerlink" title="3. vue 组件传值"></a>3. vue 组件传值</h4><p><a href="/2021/05/27/%E5%87%A0%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">几大框架知识点梳理</a></p><h4 id="4-vue生命周期钩子函数为什么不能使用箭头函数"><a href="#4-vue生命周期钩子函数为什么不能使用箭头函数" class="headerlink" title="4. vue生命周期钩子函数为什么不能使用箭头函数"></a>4. vue生命周期钩子函数为什么不能使用箭头函数</h4><p>所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 created: () &#x3D;&gt; this.fetchTodos())。因为箭头函数绑定了父系上下文，所以 this 不会指向预期的组件实例，并且this.fetchTodos 将会是 undefined。</p><p>箭头函数自己没有定义 this 上下文，而是绑定到其父函数的上下文中。当你在 Vue 程序中使用箭头函数时，this 关键字并不会绑定到 Vue 实例，因此会引发错误。</p><h4 id="5-nextTick-实现原理"><a href="#5-nextTick-实现原理" class="headerlink" title="5. nextTick 实现原理"></a>5. nextTick 实现原理</h4><p>在下次DOM更新循环结束之后执行的延迟回调。应用于需要在视图更新之后，基于新的视图进行操作。</p><p>实现原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p><blockquote><p>Promise的then -&gt; MutationObserver的回调函数 -&gt; setImmediate -&gt; setTimeout 是否存在，找到存在的就调用他childrenRef</p></blockquote><p><a href="https://juejin.cn/post/6977564213749219341" target="_blank" rel="noopener">nextTick的实现原理</a></p><h4 id="6-如何衡量组件封装的好与不好"><a href="#6-如何衡量组件封装的好与不好" class="headerlink" title="6.如何衡量组件封装的好与不好"></a>6.如何衡量组件封装的好与不好</h4><p>扩展性；如何设置扩展性比较好（预留插槽）</p><p>对于组件的设计，一般是一个组件能够完整的完成一件事情，或者一个完整的逻辑；另外组件的设计一般是讲究高内聚，低耦合等原则进行设计。一个组件的设计应该具备以下的内容：</p><ul><li>功能独立和唯一</li><li>可复⽤的模块，完成既定功能</li><li>有明确的接⼝规定</li><li>有上下⽂依赖、外部依赖资源的定义</li><li>可以独⽴发布</li></ul><h4 id="7-vue-style-scoped-属性作用是啥，如何是样式仅在当前模块生效"><a href="#7-vue-style-scoped-属性作用是啥，如何是样式仅在当前模块生效" class="headerlink" title="7. vue style scoped 属性作用是啥，如何是样式仅在当前模块生效"></a>7. vue style scoped 属性作用是啥，如何是样式仅在当前模块生效</h4><p>作用：实现组件的私有化，不对全局造成样式污染，表示当前 style 属性只属于当前模块<br>原理：打包之后，编译成特定样式，data-v-[hash]，即 CSS 带属性选择器</p><h4 id="8-Vue3-和-React的区别"><a href="#8-Vue3-和-React的区别" class="headerlink" title="8. Vue3 和 React的区别"></a>8. Vue3 和 React的区别</h4><p><a href="https://www.h5w3.com/238721.html" target="_blank" rel="noopener">Vue与React的区别和优势对比</a></p><h4 id="9-vue-key-的作用"><a href="#9-vue-key-的作用" class="headerlink" title="9. vue key 的作用"></a>9. vue key 的作用</h4><p>高效的更新虚拟 dom</p><h4 id="10-vue-router-实现原理"><a href="#10-vue-router-实现原理" class="headerlink" title="10. vue-router 实现原理"></a>10. vue-router 实现原理</h4><p><a href="/2021/08/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue%E8%B7%AF%E7%94%B1%E6%8C%87%E5%8D%97/">Vue路由</a></p><h4 id="11-v-model原理"><a href="#11-v-model原理" class="headerlink" title="11. v-model原理"></a>11. v-model原理</h4><p>v-model一般配合input框使用，实现双向数据绑定的效果，它是v-bind和v-on的语法糖，原理是通过v-bind将数据绑定给input框，再通过v-on:input，在input中的值改变时，通过$event可以获取到事件源对象 再通过target.value获取到input中更新后的值 将这个值再赋值给绑定的数据即可</p><h4 id="12-父子组件的周期执行顺序"><a href="#12-父子组件的周期执行顺序" class="headerlink" title="12. 父子组件的周期执行顺序"></a>12. 父子组件的周期执行顺序</h4><ol><li>初始化阶段时，先执行父组件的beforeCreate、created、beforeMount三个钩子函数，然后执行子组件的beforeCreate、created、beforeMount、mounted四个钩子函数，最后执行父组件的mounted钩子函数</li><li>更新阶段，先执行父组件的beforeUpdate，然后执行子组件的beforeUpdate，updated，最后执行父组件的updated</li><li>销毁阶段，先执行父组件的beforeDestroy，然后执行子组件的eforeDestroy，destroyed，最后执行父组件的destroyed</li></ol><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><h4 id="1-z-index-无效问题"><a href="#1-z-index-无效问题" class="headerlink" title="1. z-index 无效问题"></a>1. z-index 无效问题</h4><ul><li>父级元素溢出隐藏或者不显示：父元素设置了 overflow:hidden &#x2F;display:none&#x2F; 等，那么子元素如果在父元素外部绝对定位，那么调节子元素 z-index 可能不会显示</li><li>父级元素层级低，z-index 被覆盖</li><li>没有设置定位(position)属性</li><li>父级元素 position 属性为 relative</li><li>含有浮动(float)属性</li><li>IE 不兼容</li></ul><h4 id="2-水平垂直居中实现"><a href="#2-水平垂直居中实现" class="headerlink" title="2. 水平垂直居中实现"></a>2. 水平垂直居中实现</h4><h2 id="浏览器与网络安全"><a href="#浏览器与网络安全" class="headerlink" title="浏览器与网络安全"></a>浏览器与网络安全</h2><h4 id="从输入-url-到浏览器渲染经过了哪些流程"><a href="#从输入-url-到浏览器渲染经过了哪些流程" class="headerlink" title="从输入 url 到浏览器渲染经过了哪些流程"></a>从输入 url 到浏览器渲染经过了哪些流程</h4><p>URL 解析 -&gt; DNS 查询 -&gt; TCP 连接 -&gt; HTTP 请求 -&gt; 服务器响应请求 -&gt; 页面渲染</p><h4 id="http-和-网络攻击"><a href="#http-和-网络攻击" class="headerlink" title="http 和 网络攻击"></a>http 和 网络攻击</h4><p><a href="/2022/04/19/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/">写给自己的前端面试指南</a></p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h4 id="首页白屏解决"><a href="#首页白屏解决" class="headerlink" title="首页白屏解决"></a>首页白屏解决</h4><p>缓存；骨架屏；重绘，重排；减少包大小；解决阻塞；</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h4 id="1-主题色"><a href="#1-主题色" class="headerlink" title="1. 主题色"></a>1. 主题色</h4><p><a href="https://blog.csdn.net/qq_40621378/article/details/124157105" target="_blank" rel="noopener">使用scss处理多主题切换功能</a></p><h4 id="2-权限管理（菜单权限，角色权限，路由权限，页面内部权限）"><a href="#2-权限管理（菜单权限，角色权限，路由权限，页面内部权限）" class="headerlink" title="2. 权限管理（菜单权限，角色权限，路由权限，页面内部权限）"></a>2. 权限管理（菜单权限，角色权限，路由权限，页面内部权限）</h4><p>路由守卫、动态路由加载、自定义指令按钮</p><h4 id="3-token-失效刷新如何实现的"><a href="#3-token-失效刷新如何实现的" class="headerlink" title="3. token 失效刷新如何实现的"></a>3. token 失效刷新如何实现的</h4><p>现token无感刷新对于前端来说是一项常用的技术,其本质是为了优化用户体验,当token过期时不需要用户跳回登录页重新登录,而是当token失效时,进行拦截,发送刷新token的ajax,获取最新的token进行覆盖,让用户感受不到token已经过期。</p><h4 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4. webpack"></a>4. webpack</h4><p>个性化配置：拆包；less，sass 处理；打包加速优化；dll plugins；图片资源压缩</p><p>性能优化：并行压缩；dllplugin；splitchunk；混淆压缩；happypack 多线程；cache 属性，对性能优化作用最大，改善构建速度</p><h4 id="5-脚手架，一般会改哪些配置"><a href="#5-脚手架，一般会改哪些配置" class="headerlink" title="5. 脚手架，一般会改哪些配置"></a>5. 脚手架，一般会改哪些配置</h4><p>压缩的处理：插件的压缩处理，gzip 压缩，代码压缩</p><h4 id="6-浏览器兼容性问题"><a href="#6-浏览器兼容性问题" class="headerlink" title="6. 浏览器兼容性问题"></a>6. 浏览器兼容性问题</h4><h4 id="7-图片上传预览"><a href="#7-图片上传预览" class="headerlink" title="7. 图片上传预览"></a>7. 图片上传预览</h4><p>图片存在本地，通过 base64 转化</p><h4 id="8-单点登录实现"><a href="#8-单点登录实现" class="headerlink" title="8. 单点登录实现"></a>8. 单点登录实现</h4><p>单点登录（SSO），指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的系统。多个系统，统一登陆。</p><p>实现原理：sso需要一个独立的认证中心，所有子系统都通过认证中心的登录入口进行登录，登录时带上自己的地址，子系统只接受认证中心的授权，授权通过令牌（token）实现，sso认证中心验证用户的用户名密码正确，创建全局会话和token，token作为参数发送给各个子系统，子系统拿到token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><p>单点登录的实现方案，一般就包含：Cookies，Session同步，分布式Session，目前的大型网站都是采用分布式Session的方式。</p><h4 id="9-第三方登录对接"><a href="#9-第三方登录对接" class="headerlink" title="9. 第三方登录对接"></a>9. 第三方登录对接</h4><p><a href="https://blog.csdn.net/weixin_43594183/article/details/117132759" target="_blank" rel="noopener">前端对接第三方登录</a></p><h4 id="10-微信公众号，小程序的开发的区别，登陆的过程；微信公众号如何判断怎么获取-unnid"><a href="#10-微信公众号，小程序的开发的区别，登陆的过程；微信公众号如何判断怎么获取-unnid" class="headerlink" title="10. 微信公众号，小程序的开发的区别，登陆的过程；微信公众号如何判断怎么获取 unnid"></a>10. 微信公众号，小程序的开发的区别，登陆的过程；微信公众号如何判断怎么获取 unnid</h4><h4 id="11-PC端扫码实现"><a href="#11-PC端扫码实现" class="headerlink" title="11. PC端扫码实现"></a>11. PC端扫码实现</h4><p><a href="https://www.163.com/dy/article/HB9DL32505537S0S.html" target="_blank" rel="noopener">扫码登录是如何实现的</a></p><h4 id="12-大数据量的问题处理"><a href="#12-大数据量的问题处理" class="headerlink" title="12. 大数据量的问题处理"></a>12. 大数据量的问题处理</h4><p>分页，分片，虚拟滚动，关键字远程搜索，异步加载</p><h4 id="13-跨域问题解决"><a href="#13-跨域问题解决" class="headerlink" title="13. 跨域问题解决"></a>13. 跨域问题解决</h4><p>JSONP；iframe；postMessage；CORS；Proxy；WebSocket</p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>养猫指南大全</title>
    <url>/2021/08/04/%E5%85%BB%E7%8C%AB%E6%8C%87%E5%8D%97%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="养猫之前需要了解的："><a href="#养猫之前需要了解的：" class="headerlink" title="养猫之前需要了解的："></a>养猫之前需要了解的：</h2><h4 id="疫苗"><a href="#疫苗" class="headerlink" title="疫苗"></a>疫苗</h4><p>猫咪是否打过猫三联疫苗和狂犬疫苗，打过的话会一般有小本本。（一般1年打一次，1年带猫咪做一次体检）</p><h4 id="驱虫"><a href="#驱虫" class="headerlink" title="驱虫"></a>驱虫</h4><p>是否驱虫，准备好驱虫药，后期自己定期给猫驱虫。</p><a id="more"></a><p>驱虫分内驱、外驱、内外同驱3种方式。</p><p>猫咪刚到新家，刚注射完疫苗的7天内，生病时等情况下，都不适合驱虫。建议是断奶后，大概两个月左右开始驱虫。</p><p>六个月以后的猫咪：如果猫咪不外出、不捕猎、不吃生肉的情况下，可以每隔3个月驱虫一次（体内3个月1次，体外2个月一次（体外驱虫一定要带伊丽莎白圈防止猫猫舔舐，且驱虫后2天内不能洗澡））。</p><h2 id="带猫咪回家之前，你需要准备的东西"><a href="#带猫咪回家之前，你需要准备的东西" class="headerlink" title="带猫咪回家之前，你需要准备的东西"></a>带猫咪回家之前，你需要准备的东西</h2><h4 id="自动饮水机"><a href="#自动饮水机" class="headerlink" title="自动饮水机"></a>自动饮水机</h4><p>猫咪也需要多喝水，尤其是公猫，喝水太少的话容易有泌尿系统的疾病</p><h4 id="航空箱"><a href="#航空箱" class="headerlink" title="航空箱"></a>航空箱</h4><h4 id="猫抓板（2块）或者-猫爬架"><a href="#猫抓板（2块）或者-猫爬架" class="headerlink" title="猫抓板（2块）或者 猫爬架"></a>猫抓板（2块）或者 猫爬架</h4><h4 id="选择性"><a href="#选择性" class="headerlink" title="选择性"></a>选择性</h4><ul><li>猫罐头（主食罐头）</li><li>羊奶粉（幼猫）</li></ul><h2 id="养猫之前，你必需要知道的安全知识："><a href="#养猫之前，你必需要知道的安全知识：" class="headerlink" title="养猫之前，你必需要知道的安全知识："></a>养猫之前，你必需要知道的安全知识：</h2><ol><li>猫窝不要买</li><li>封窗</li></ol><h2 id="新猫到家，需要注意的事项："><a href="#新猫到家，需要注意的事项：" class="headerlink" title="新猫到家，需要注意的事项："></a>新猫到家，需要注意的事项：</h2><ol><li>接回家之前，要给猫猫体检，确保没有寄生虫等其他疾病，确认猫猫疫苗接种情况</li><li>进门第一件事：把猫咪从航空箱里抱到猫砂盆里，让它闻一下，也可以轻轻用它的小爪子扒拉两下。让小猫知道这是上厕所的地方</li><li>大部分猫咪胆子都很小，可能会钻到沙发&#x2F; 床底下躲起来。因为呆在狭窄且黑暗的地方，猫咪会比较有感全感。</li></ol><h2 id="日常护理建议"><a href="#日常护理建议" class="headerlink" title="日常护理建议"></a>日常护理建议</h2><h4 id="注意饮食"><a href="#注意饮食" class="headerlink" title="注意饮食"></a>注意饮食</h4><p>猫的饮食最好的是：湿粮&gt;成品干粮&gt;菜汤拌饭</p><p>宠物幼年时期就要注意饮食，因为这直接决定了它们成年后的免疫力、发育能力、抵抗力。成年后的宠物要注意不要喂高糖、高盐、高脂肪食物。</p><p>宠物的便便关系着它的身体健康，铲屎官们要学会观察，及时判断异常，宠物便便形态分级可见下图：</p><p><img src="/images/cat/cat_poop.jpg" alt="cat"></p><h4 id="猫猫食物"><a href="#猫猫食物" class="headerlink" title="猫猫食物"></a>猫猫食物</h4><ol><li>猫粮（换猫粮的时候需要将新粮和旧粮按照比例1:5&#x2F;2:5&#x2F;1:2&#x2F;3:5&#x2F;4:5&#x2F;全新。这样的比例更换）</li></ol><p>选猫粮最简单的办法就是看成分表，前几位都是肉就是好粮食</p><ol start="2"><li>化毛膏&#x2F;猫草</li><li>营养膏</li><li>喝水：一定要用烧开晾凉的水，或者矿泉水都可以（水要每天更换，自动喂水器可以3-5天更换）</li></ol><h4 id="猫猫用品"><a href="#猫猫用品" class="headerlink" title="猫猫用品"></a>猫猫用品</h4><ol><li>猫碗2个（吃饭一个，喝水一个）</li><li>猫砂盆1（推荐封闭式或顶入式，不然猫砂会被猫猫播出来，同时猫屎很臭）</li><li>猫砂（推荐豆腐猫砂，可以冲厕所的，很省事）</li><li>指甲剪（猫咪专用的那种）</li><li>宠物梳子（梳毛用）</li><li>猫咪沐浴液</li><li>猫用牙刷牙膏</li><li>毛巾（推荐鹿皮毛巾，超级吸水超便宜）</li><li>针管20ml(供强制猫猫喝水喂药用)</li><li>伊丽莎白圈（给猫驱虫时用需要带头上防止他舔舐）</li><li>猫笼（你打扫卫生或者他犯错误都可以先关进去）</li><li>猫药品（体内驱虫药片，体外驱虫滴剂，益生菌，洗耳液，猫咪赖氨酸，眼药水）</li><li>猫消毒（杜邦卫可消毒粉）</li></ol><h4 id="猫猫药品"><a href="#猫猫药品" class="headerlink" title="猫猫药品"></a>猫猫药品</h4><ol><li>益生菌，2天一次加到猫食物里调节猫咪肠胃，防止软便拉稀</li><li>洗耳液，法国维克洗耳液，滴入猫耳朵里，扣住按摩松开猫咪会自动将脏东西甩出，再擦干 就好。预防猫咪耳部疾病</li><li>赖氨酸，猫咪受凉得了感冒就是大病，很难治，所以在天气要转冷或者夏天常开空调记得给猫加到饭里作为预防</li><li>眼药水，这个不是必须，但是猫咪有时候会不小心眼睛感染，流浑浊泪水，眼屎多，这个时候就需要眼药水帮它康复，托百士就可以。特别严重还是要上医院</li><li>杜邦卫可消毒粉，这个是能有效抵御猫瘟病毒的消毒粉，一般用它一周拖地消毒，以及用来喷他的饭碗，舔舐也无害</li></ol><h4 id="日常清理"><a href="#日常清理" class="headerlink" title="日常清理"></a>日常清理</h4><ol><li>早晚铲屎，猫砂每天更换</li><li>一周剪指甲一次，一周刷牙一次，一周梳毛一次，1～2周清洗一次耳朵</li><li>每隔半年洗一次澡（一般猫咪都很怕自己的毛沾湿，所以也很抗拒洗澡，洗澡也容易让猫咪受惊，产生应激反应，洗澡后要吹干）</li></ol><h2 id="其他养猫的基础知识"><a href="#其他养猫的基础知识" class="headerlink" title="其他养猫的基础知识"></a>其他养猫的基础知识</h2><p>1.猫打呼噜<br>2.清洁猫砂盆：最好是一天一次<br>3.猫咪可绝育年龄：6个月-1岁左右（母猫7个月大绝育，公猫6个月大绝育）<br>4.不要出门遛猫<br>5.如果要出远门，最好找朋友隔两天来家里照顾下猫咪</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>D3力导图的canvas实现</title>
    <url>/2019/04/23/d3%E5%8A%9B%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>之前一直默认的d3-svg画图，使用svg的好处是方便操作dom元素, 添加用户交互，操作起来很方便，但后期发现展示大量数据时用svg渲染会造成页面卡顿。因此最近研究了下d3画canvas，在需要展示的数据量很大且交互少的时候适合用canvas。</p><a id="more"></a><p>canvas和svg都能实现同样的效果，如图：</p><p><img src="/images/d3/force.png" alt="force"></p><p>简单的示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"graph"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"myforce.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> data = &#123;</span></span><br><span class="line"><span class="javascript">    nodes:[&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'a'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'b'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'c'</span>&#125;,</span></span><br><span class="line"><span class="javascript">    &#123;<span class="attr">id</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">'d'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">5</span>,<span class="attr">name</span>:<span class="string">'e'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">6</span>,<span class="attr">name</span>:<span class="string">'f'</span>&#125;,</span></span><br><span class="line"><span class="javascript">    &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">name</span>:<span class="string">'g'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">'h'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">9</span>,<span class="attr">name</span>:<span class="string">'i'</span>&#125;,</span></span><br><span class="line"><span class="javascript">    &#123;<span class="attr">id</span>:<span class="number">10</span>,<span class="attr">name</span>:<span class="string">'j'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">11</span>,<span class="attr">name</span>:<span class="string">'k'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">12</span>,<span class="attr">name</span>:<span class="string">'l'</span>&#125;,</span></span><br><span class="line"><span class="javascript">    &#123;<span class="attr">id</span>:<span class="number">13</span>,<span class="attr">name</span>:<span class="string">'m'</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">14</span>,<span class="attr">name</span>:<span class="string">'n'</span>&#125;],</span></span><br><span class="line">    edges:[&#123;source:1,target:5&#125;,&#123;source:2,target:3&#125;,</span><br><span class="line">    &#123;source:1,target:3&#125;,&#123;source:4,target:12&#125;,</span><br><span class="line">    &#123;source:5,target:7&#125;,&#123;source:1,target:4&#125;,</span><br><span class="line">    &#123;source:1,target:10&#125;,&#123;source:1,target:9&#125;,</span><br><span class="line">    &#123;source:6,target:3&#125;,&#123;source:4,target:14&#125;,</span><br><span class="line">    &#123;source:5,target:8&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> force = <span class="keyword">new</span> MyForce(&#123;</span></span><br><span class="line"><span class="javascript">    el:<span class="string">'#graph'</span>,</span></span><br><span class="line"><span class="javascript">    height:<span class="built_in">window</span>.innerHeight - <span class="number">50</span>,</span></span><br><span class="line"><span class="javascript">    width:<span class="built_in">window</span>.innerWidth - <span class="number">50</span>,</span></span><br><span class="line">    nodes: data.nodes,</span><br><span class="line">    edges: data.edges,</span><br><span class="line"><span class="javascript">    type:<span class="string">"canvas"</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>myforce.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> MyForce = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.options = options;</span><br><span class="line">	<span class="keyword">this</span>.width = options.width||<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">this</span>.height = options.height||<span class="number">400</span>;</span><br><span class="line">	<span class="keyword">this</span>.el = options.el || <span class="string">"body"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.transform = d3.zoomIdentity;</span><br><span class="line">	<span class="keyword">this</span>.scale = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">this</span>.radius = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">this</span>.selectNode = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">this</span>.selectEdge = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">this</span>.defaultColor = options.defaultColor || <span class="string">"#52BAFF"</span>;</span><br><span class="line">	<span class="keyword">this</span>.lightColor = <span class="string">"#fec10e"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.nodes = options.nodes||[];</span><br><span class="line">	<span class="keyword">this</span>.edges = options.edges||[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.type = options.type||<span class="string">'svg'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.simulation = d3.forceSimulation()</span><br><span class="line">          .force(<span class="string">"center"</span>, d3.forceCenter(<span class="keyword">this</span>.width / <span class="number">2</span>, <span class="keyword">this</span>.height / <span class="number">2</span>))</span><br><span class="line">          .force(<span class="string">"x"</span>, d3.forceX(<span class="keyword">this</span>.width / <span class="number">2</span>).strength(<span class="number">0.1</span>))</span><br><span class="line">          .force(<span class="string">"y"</span>, d3.forceY(<span class="keyword">this</span>.height / <span class="number">2</span>).strength(<span class="number">0.1</span>))</span><br><span class="line">          .force(<span class="string">"charge"</span>, d3.forceManyBody().strength(<span class="number">-100</span>))</span><br><span class="line">          .force(<span class="string">"link"</span>, d3.forceLink().strength(<span class="number">1</span>).id(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.id; &#125;))</span><br><span class="line">          .alphaTarget(<span class="number">0</span>)</span><br><span class="line">          .alphaDecay(<span class="number">0.05</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// type</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.type == <span class="string">'svg'</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.forceBySvg();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.forceByCanvas();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canvas渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyForce.prototype.forceByCanvas = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> myForce = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">//append canvas</span></span><br><span class="line">	myForce.canvas = d3.select(myForce.el).append(<span class="string">"canvas"</span>)</span><br><span class="line">    .attr(<span class="string">"height"</span>, myForce.height+<span class="string">'px'</span>)</span><br><span class="line">    .attr(<span class="string">"width"</span>, myForce.width+<span class="string">'px'</span>).node();</span><br><span class="line">	myForce.context = myForce.canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add tick and links</span></span><br><span class="line">	myForce.simulation.nodes(myForce.nodes).on(<span class="string">"tick"</span>,forceTick);</span><br><span class="line">	myForce.simulation.force(<span class="string">"link"</span>).links(myForce.edges);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//drag</span></span><br><span class="line">	d3.select(myForce.canvas)</span><br><span class="line">        .call(d3.drag().container(myForce.canvas).subject(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">"dragsubject"</span>)</span><br><span class="line">			    <span class="keyword">var</span> i,</span><br><span class="line">			    x = myForce.transform.invertX(d3.event.x),</span><br><span class="line">			    y = myForce.transform.invertY(d3.event.y),</span><br><span class="line">			    dx,</span><br><span class="line">			    dy;</span><br><span class="line">			    <span class="keyword">for</span> (i = myForce.nodes.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			      <span class="keyword">var</span> node = myForce.nodes[i];</span><br><span class="line">			      dx = x - node.x;</span><br><span class="line">			      dy = y - node.y;</span><br><span class="line"></span><br><span class="line">			      <span class="keyword">if</span> (dx * dx + dy * dy &lt; myForce.radius * myForce.radius) &#123;</span><br><span class="line"></span><br><span class="line">			        node.x =  myForce.transform.applyX(node.x);</span><br><span class="line">			        node.y = myForce.transform.applyY(node.y);</span><br><span class="line">			        <span class="keyword">return</span> node;</span><br><span class="line">			      &#125;</span><br><span class="line">			    &#125;</span><br><span class="line">        &#125;).on(<span class="string">"start"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br><span class="line">        	<span class="keyword">if</span> (!d3.event.active) myForce.simulation.alphaTarget(<span class="number">0.3</span>).restart();</span><br><span class="line">    		d3.event.subject.fx = myForce.transform.invertX(d3.event.x);</span><br><span class="line">    		d3.event.subject.fy = myForce.transform.invertY(d3.event.y);</span><br><span class="line">        &#125;).on(<span class="string">"drag"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="comment">// console.log("drag",d3.event)</span></span><br><span class="line">        	d3.event.subject.fx = myForce.transform.invertX(d3.event.x);</span><br><span class="line">    		d3.event.subject.fy = myForce.transform.invertY(d3.event.y);</span><br><span class="line">        &#125;).on(<span class="string">"end"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">"end"</span>)</span><br><span class="line">        	<span class="keyword">if</span> (!d3.event.active) myForce.simulation.alphaTarget(<span class="number">0</span>);</span><br><span class="line">		    d3.event.subject.fx = <span class="literal">null</span>;</span><br><span class="line">		    d3.event.subject.fy = <span class="literal">null</span>;</span><br><span class="line">        &#125;))</span><br><span class="line">        .call(d3.zoom().scaleExtent([<span class="number">1</span> / <span class="number">10</span>, <span class="number">8</span>]).on(<span class="string">"zoom"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	myForce.transform = d3.event.transform;</span><br><span class="line">    		forceTick();</span><br><span class="line">        &#125;))</span><br><span class="line">        .on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="comment">// console.log("click")</span></span><br><span class="line">        	<span class="keyword">var</span> point = d3.mouse(<span class="keyword">this</span>),node=<span class="literal">null</span>,minDistance = <span class="literal">Infinity</span>,edge = <span class="literal">null</span>;</span><br><span class="line">        	<span class="built_in">console</span>.log(point,myForce.transform)</span><br><span class="line">        	myForce.nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        		<span class="keyword">var</span> dx = d.x - point[<span class="number">0</span>],</span><br><span class="line">				    dy = d.y - point[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">var</span> distance = <span class="built_in">Math</span>.sqrt((dx * dx) + (dy * dy));</span><br><span class="line">			    <span class="keyword">if</span> (distance &lt; minDistance &amp;&amp; distance &lt; myForce.radius + <span class="number">10</span>) &#123;</span><br><span class="line">					minDistance = distance;</span><br><span class="line">					node = d;</span><br><span class="line">				&#125;</span><br><span class="line">        	&#125;)</span><br><span class="line">        	myForce.selectNode = node;</span><br><span class="line">        	myForce.selectEdge = edge;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tick</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">forceTick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		myForce.context.save();</span><br><span class="line"></span><br><span class="line">	    myForce.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, myForce.width, myForce.height);</span><br><span class="line">	    myForce.context.translate(myForce.transform.x, myForce.transform.y);</span><br><span class="line">	    myForce.context.scale(myForce.transform.k, myForce.transform.k);</span><br><span class="line"></span><br><span class="line">	    myForce.drawCanvasEdges();</span><br><span class="line">	    myForce.drawCanvasNodes();</span><br><span class="line"></span><br><span class="line">	    myForce.context.restore();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 画线</span></span><br><span class="line">MyForce.prototype.drawCanvasEdges = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> myForce = <span class="keyword">this</span>;</span><br><span class="line">    myForce.context.beginPath();</span><br><span class="line">    myForce.edges.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        myForce.context.moveTo(d.source.x, d.source.y);</span><br><span class="line">        myForce.context.lineTo(d.target.x, d.target.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myForce.selectEdge &amp;&amp; d === myForce.selectEdge) &#123;</span><br><span class="line">			myForce.context.strokeStyle = myForce.lightColor;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			myForce.context.strokeStyle = <span class="string">"#aaa"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    myForce.context.stroke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 画点</span></span><br><span class="line">MyForce.prototype.drawCanvasNodes = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> myForce = <span class="keyword">this</span>;</span><br><span class="line">    myForce.nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">        myForce.context.beginPath();</span><br><span class="line">        <span class="comment">// p.moveTo(d.x, d.y);</span></span><br><span class="line">        myForce.context.arc(d.x, d.y, myForce.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (myForce.selectNode &amp;&amp; d === myForce.selectNode) &#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(myForce.selectNode)</span><br><span class="line">			myForce.context.fillStyle = myForce.lightColor;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			myForce.context.fillStyle = myForce.defaultColor;</span><br><span class="line">		&#125;</span><br><span class="line">        myForce.context.fill();</span><br><span class="line">        <span class="comment">// add text</span></span><br><span class="line">        myForce.context.fillStyle = <span class="string">"#333"</span>;</span><br><span class="line">    	myForce.context.font = <span class="string">"8px"</span>;</span><br><span class="line">        myForce.context.fillText(d.name,d.x-myForce.radius*<span class="number">2</span>+<span class="number">3</span>,d.y+myForce.radius*<span class="number">2</span>+<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>svg渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyForce.prototype.forceBySvg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> myForce = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append svg</span></span><br><span class="line">	myForce.svg = d3.select(myForce.el).append(<span class="string">"svg"</span>)</span><br><span class="line">    .attr(<span class="string">"height"</span>, myForce.height).attr(<span class="string">"width"</span>, myForce.width);</span><br><span class="line">	myForce.svgG = myForce.svg.append(<span class="string">'g'</span>).attr(<span class="string">"transform"</span>, <span class="string">"translate(0,0)"</span>);</span><br><span class="line">	myForce.svgTransformX = <span class="number">0</span>;</span><br><span class="line">	myForce.svgTransformY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//drag svg and zoom</span></span><br><span class="line">	<span class="keyword">this</span>.svg.call(d3.drag().on(<span class="string">"drag"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">		myForce.svgTransformX += d3.event.x - d3.event.subject.x;</span><br><span class="line">        myForce.svgTransformY += d3.event.y - d3.event.subject.y;</span><br><span class="line">        d3.event.subject.x = d3.event.x;</span><br><span class="line">        d3.event.subject.y = d3.event.y;</span><br><span class="line"></span><br><span class="line">        myForce.translateX= myForce.svgTransformX;</span><br><span class="line">        myForce.translateY= myForce.svgTransformY;</span><br><span class="line">        myForce.svgG.attr(<span class="string">"transform"</span>, <span class="string">"translate("</span> + myForce.svgTransformX + <span class="string">" "</span> + myForce.svgTransformY + <span class="string">")scale("</span> + myForce.scale + <span class="string">")"</span>);</span><br><span class="line">	&#125;).on(<span class="string">"end"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;))</span><br><span class="line">    .call(d3.zoom().scaleExtent([ <span class="number">0.2</span>, <span class="number">5</span> ])</span><br><span class="line">      .on(<span class="string">"zoom"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	<span class="keyword">var</span> scale = <span class="number">1</span>;</span><br><span class="line">  		<span class="keyword">var</span> removeX = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">var</span> removeY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  		scale = d3.event.transform.k;</span><br><span class="line">  		removeX =   d3.event.transform.x;</span><br><span class="line">  		removeY =   d3.event.transform.y;</span><br><span class="line"></span><br><span class="line">  		myForce.translateX= myForce.svgTransformX;</span><br><span class="line">  	    myForce.translateY= myForce.svgTransformY;</span><br><span class="line"></span><br><span class="line">  		myForce.scale = scale;</span><br><span class="line"></span><br><span class="line">  		myForce.svgG.attr(<span class="string">"transform"</span>, <span class="string">"translate("</span> + myForce.svgTransformX + <span class="string">" "</span> + myForce.svgTransformY + <span class="string">")scale("</span> + myForce.scale + <span class="string">")"</span>);</span><br><span class="line">      &#125;))</span><br><span class="line">    .on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  		<span class="keyword">if</span> (d3.event == <span class="literal">null</span> || d3.event.target.nodeName == <span class="string">"svg"</span> ) &#123;</span><br><span class="line">  			<span class="built_in">console</span>.log(<span class="string">'svg'</span>)</span><br><span class="line">  			myForce.selectNode = <span class="literal">null</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;)</span><br><span class="line"></span><br><span class="line">    myForce.drawLinksAndNodes();</span><br><span class="line">&#125;</span><br><span class="line">MyForce.prototype.drawLinksAndNodes = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> myForce = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">// add links</span></span><br><span class="line">	<span class="keyword">let</span> links = myForce.svgG.append(<span class="string">"g"</span>)</span><br><span class="line">     	.attr(<span class="string">"class"</span>, <span class="string">"links"</span>)</span><br><span class="line">	    .selectAll(<span class="string">"line"</span>)</span><br><span class="line">	    .data(myForce.edges)</span><br><span class="line">	    .enter().append(<span class="string">"line"</span>)</span><br><span class="line">	    .attr(<span class="string">"stroke"</span>,<span class="string">"#aaa"</span>)</span><br><span class="line">        .attr(<span class="string">"stroke-width"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// add nodes</span></span><br><span class="line">    <span class="keyword">let</span> nodes = myForce.svgG.append(<span class="string">"g"</span>)</span><br><span class="line">	    .attr(<span class="string">"class"</span>, <span class="string">"nodes"</span>)</span><br><span class="line">	    .selectAll(<span class="string">"g"</span>)</span><br><span class="line">	    .data(myForce.nodes)</span><br><span class="line">	    .enter()</span><br><span class="line">	    .append(<span class="string">"g"</span>)</span><br><span class="line">	    .attr(<span class="string">"class"</span>, <span class="string">"node"</span>)</span><br><span class="line">	    .style(<span class="string">"cursor"</span>,<span class="string">"pointer"</span>)</span><br><span class="line">	    .call(d3.drag()</span><br><span class="line">            .on(<span class="string">"start"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">            	d3.select(<span class="keyword">this</span>).raise();</span><br><span class="line">            	<span class="keyword">if</span> (!d3.event.active) myForce.simulation.alphaTarget(<span class="number">0.3</span>).restart();</span><br><span class="line">				d.fx = d.x;</span><br><span class="line">				d.fy = d.y;</span><br><span class="line">            &#125;)</span><br><span class="line">            .on(<span class="string">"drag"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">            	d.fx = d3.event.x;</span><br><span class="line">  				d.fy = d3.event.y;</span><br><span class="line">            &#125;)</span><br><span class="line">            .on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">			    <span class="keyword">if</span> (!d3.event.active) myForce.simulation.alphaTarget(<span class="number">0</span>);</span><br><span class="line">			    d.fx = <span class="literal">null</span>;</span><br><span class="line">			    d.fy = <span class="literal">null</span>;</span><br><span class="line">            &#125;))</span><br><span class="line">	    .on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">	    	myForce.selectNode = d;</span><br><span class="line">	    	<span class="keyword">if</span>(circles)&#123;</span><br><span class="line">	    		circles.attr(<span class="string">"fill"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">	    			<span class="keyword">if</span>(node == myForce.selectNode)&#123;</span><br><span class="line">	    				<span class="keyword">return</span> myForce.lightColor;</span><br><span class="line">	    			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    				<span class="keyword">return</span> myForce.defaultColor;</span><br><span class="line">	    			&#125;</span><br><span class="line">	    		&#125;)</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> circles = nodes.append(<span class="string">"circle"</span>).attr(<span class="string">"r"</span>, myForce.radius)</span><br><span class="line">        .attr(<span class="string">"fill"</span>,myForce.defaultColor);</span><br><span class="line">	<span class="keyword">let</span> texts = nodes.append(<span class="string">"text"</span>).attr(<span class="string">"text-anchor"</span>,<span class="string">"middle"</span>)</span><br><span class="line">		.append(<span class="string">"tspan"</span>).text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d.name;&#125;)</span><br><span class="line">		.attr(<span class="string">"fill"</span>,<span class="string">"#333"</span>)</span><br><span class="line">		.style(<span class="string">"font-size"</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// simulation tick</span></span><br><span class="line">	myForce.simulation.nodes(myForce.nodes)</span><br><span class="line">      .on(<span class="string">"tick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	    links.attr(<span class="string">"x1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.source.x; &#125;)</span><br><span class="line">		        .attr(<span class="string">"y1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.source.y; &#125;)</span><br><span class="line">		        .attr(<span class="string">"x2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.target.x; &#125;)</span><br><span class="line">		        .attr(<span class="string">"y2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.target.y; &#125;);</span><br><span class="line"></span><br><span class="line">		    circles.attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.x; &#125;)</span><br><span class="line">			    .attr(<span class="string">"cy"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.y; &#125;);</span><br><span class="line"></span><br><span class="line">			texts.attr(<span class="string">"dx"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d.x; &#125;)</span><br><span class="line">				.attr(<span class="string">"dy"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d.y + myForce.radius*<span class="number">2</span>+<span class="number">3</span>; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    myForce.simulation.force(<span class="string">"link"</span>).links(myForce.edges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝试一下实现简单的Vue3</title>
    <url>/2022/08/02/%E6%B5%85%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8B%E6%89%8B%E5%86%99Vue/</url>
    <content><![CDATA[<p><img src="/images/vue/vue_160301.png" alt="vue3"></p><a id="more"></a><h2 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h2><p>作用：虚拟DOM转成真实DOM。</p><p>工作原理：递归地遍历虚拟DOM，调用原生js创建真实的DOM。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟DOM就是一个用来描述真实DOM的JS对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'This is a div'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  children: <span class="string">'click me'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>虚拟DOM元素的封装，可以是返回虚拟DOM的函数，也可以是一个对象（这个对象必须有一个函数用来产出组件要渲染的虚拟DOM）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myComponent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag: <span class="string">'div'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      onClick: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'This is a div'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    children: <span class="string">'click me'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个渲染器"><a href="#实现一个渲染器" class="headerlink" title="实现一个渲染器"></a>实现一个渲染器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设一个虚拟dom</span></span><br><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  tag: myComponent</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderer</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断vnode描述的是dom标签还是组件</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> vnode.tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    mountElement(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> vnode.tag === <span class="string">'function'</span>) &#123;</span><br><span class="line">    mountComponent(vnode, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染标签元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建元素</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(vnode.tag)</span><br><span class="line">  <span class="comment">// 绑定事件或设置属性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> vnode.props) &#123;</span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    <span class="keyword">if</span>(key.startsWith(<span class="string">'on'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> eName = key.substr(<span class="number">2</span>).toLowerCase()</span><br><span class="line">      el.addEventListener(eName, vnode.props[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// children</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> vnode.children === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本节点</span></span><br><span class="line">    el.appendChild(<span class="built_in">document</span>.createTextNode(vnode.children))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(vnode.children <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归添加子元素</span></span><br><span class="line">    vnode.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> renderer(child, el))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(container) container.appendChild(el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用组件函数获取虚拟dom</span></span><br><span class="line">  <span class="keyword">const</span> subtree = vnode.tag()</span><br><span class="line">  <span class="comment">// 递归的调用渲染函数</span></span><br><span class="line">  renderer(subtree, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><p>实现原理：对数据的“读取”和“设置”操作的拦截，在<code>副作用函数</code>和响应式数据间建立联系。当“读取”时，把当前执行的副作用函数放入“桶”；当“设置”时，把副作用函数取出并执行。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>可以创建一个代理对象，能够实现对其他对象的代理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取属性</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;&#125;,</span><br><span class="line">  <span class="comment">// 拦截设置属性</span></span><br><span class="line">  <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现简单的响应式数据"><a href="#实现简单的响应式数据" class="headerlink" title="实现简单的响应式数据"></a>实现简单的响应式数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局变量存被注册的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//设置当前激活的副作用函数</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    activeEffect = fn</span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存所有与该副作用函数相关联的依赖集合</span></span><br><span class="line">  effectFn.deps = []</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  effectFn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存副作用函数的桶</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// new Set() =&gt; 副作用函数没有和目标对象字段绑定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	WeakMap由 target --&gt; Map 构成</span></span><br><span class="line"><span class="comment">	Map由 key --&gt; Set 构成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取属性</span></span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="comment">// 副作用函数添加到桶</span></span><br><span class="line">    track(target, key)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置属性</span></span><br><span class="line">  <span class="keyword">set</span>(target, key, newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="comment">// 取出副作用函数并执行</span></span><br><span class="line">    trigger(target, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 没有activeEffect</span></span><br><span class="line">  <span class="keyword">if</span>(!activeEffect) <span class="keyword">return</span> target[key]</span><br><span class="line">  <span class="comment">// 从桶中获取depsMap</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.get(target) <span class="comment">// Map类型</span></span><br><span class="line">  <span class="comment">// 没有depsMap，新建一个与target绑定</span></span><br><span class="line">  <span class="keyword">if</span>(!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    bucket.set(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取与key相关的所有副作用函数</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.get(key) <span class="comment">// Set类型</span></span><br><span class="line">  <span class="keyword">if</span>(!deps) &#123;</span><br><span class="line">    deps = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    depsMap.set(key, deps)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存副作用函数</span></span><br><span class="line">  <span class="comment">// bucket.add(activeEffect)</span></span><br><span class="line">  <span class="comment">// 添加当前激活的副作用函数</span></span><br><span class="line">  deps.add(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出副作用函数并执行</span></span><br><span class="line">  <span class="comment">// bucket.forEach(fn =&gt; fn())</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.get(target)</span><br><span class="line">  <span class="keyword">if</span>(!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 获取与key相关的所有副作用函数</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.get(key)</span><br><span class="line">  effects &amp;&amp; effects.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要执行的副作用函数</span></span><br><span class="line">effect(<span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = obj.text</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性实际上是一个懒执行的副作用函数</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>实现原理：利用副作用函数重新执行时的可调度性</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>作用：将模板字符串编译成渲染函数。</p><ul><li>用来将模板字符串解析为模板AST的解析器（parser）</li><li>用来将模板AST转换为JavaScript AST的转换器（transformer）</li><li>根据JavaScript AST生成渲染函数代码的生成器（generator）</li></ul><h3 id="实现一个编译器"><a href="#实现一个编译器" class="headerlink" title="实现一个编译器"></a>实现一个编译器</h3>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2和Vue3原理区别</title>
    <url>/2019/04/23/%E5%AF%B9Vue%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h2><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><p>用数据劫持结合发布者-订阅者模式，通过<code>Object.defineProperty()</code>(可以控制一个对象属性的一些特有操作)来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><a id="more"></a><ol><li>Observer：监听器，监听数据变化，对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li><li>Compile：解析指令，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li><li>Watcher:订阅者，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>Vue的核心功能强调的是状态到界面的映射</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123; ... &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123; ... &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>，是<code>Model-View-ViewModel</code>的简写，是M-V-VM三部分组成。MVVM 的ViewModel将视图 UI 和业务逻辑分开，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。</p><p>MVVM采用双向数据绑定，view中数据变化将自动反映到viewModel上，反之，model中数据变化也将会自动展示在页面上。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。</p><p>MVVM核心思想，是关注model的变化，让MVVM框架利用自己的机制自动更新DOM，也就是所谓的数据-视图分离，数据不会影响视图。</p><p>优点：</p><ul><li>Controller简洁清晰</li><li>开发解耦、方便测试</li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟DOM就是为了解决浏览器性能问题，Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。虚拟DOM就是一个用来表示真实DOM的对象。<br>1.用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 –&gt; VNode</p><p>2.当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 –&gt; diff</p><p>3.把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 –&gt; patch</p><p>所谓的virtual dom，也就是虚拟节点。它通过js的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点 dom。diff 则是通过JS层面的计算，返回一个patch对象，即补丁对象，在通过特定的操作解析patch对象，完成页面的重新渲染。</p><p>优点：</p><ul><li>不会进行回流和重绘；</li><li>对于频繁操作，只进行一次对比差异并修改真实 DOM，减少了真实 DOM 中多次回流重绘引起的性能损耗；</li><li>有效降低大面积的重绘与排版，只更新差异部分，进行渲染局部。</li></ul><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>Diff算法是一种用来对比新旧虚拟DOM的算法，通过对比找出改变的虚拟DOM，然后单独更新这个虚拟DOM对应的真实节点，提高性能。</p><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:广度优先算法。 时间复杂度:O(n)。</p><h4 id="vue的diff算法优化"><a href="#vue的diff算法优化" class="headerlink" title="vue的diff算法优化"></a>vue的diff算法优化</h4><p>当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。</p><p>整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM（React则是将更新放入队列后集中处理）</p><p>优先处理特殊场景、“原地复用”（Vue会尽可能复用DOM，尽可能不发生DOM的移动）</p><h3 id="与Angular区别"><a href="#与Angular区别" class="headerlink" title="与Angular区别"></a>与Angular区别</h3><p>与Aangular双向数据绑定不同，Vue组件不能检测到实例化后data属性的添加、删除，因为Vue组件在实例化时才会对属性执行getter&#x2F;setter处理，所以data对象上的属性必须在实例化之前存在，Vue才能够正确的进行转换。因而，Vue提供的并非真正意义上的双向绑定，更准确的描述应该是单向绑定，响应式更新，而Angular即可以通过$scope影响view上的数据绑定，也可以通过视图层操作$scope上的对象属性，属于真正意义上的视图与模型的双向绑定。</p><h3 id="vue2原理存在的问题"><a href="#vue2原理存在的问题" class="headerlink" title="vue2原理存在的问题"></a>vue2原理存在的问题</h3><ul><li>初始化时需要遍历对象所有 key，如果对象层次较深，性能不好</li><li>通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多</li><li>Object.defineProperty 无法监听到数组元素及数组长度的变化，只能通过劫持重写会改变原数组的方法</li><li>动态新增，删除对象属性无法拦截，只能用特定 Vue.set()&#x2F;delete 解决</li><li>不支持 Map、Set、WeakMap 等数据结构</li></ul><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><p>用 <code>Proxy</code> 代替 <code>Object.defineProperty</code> 重构了响应式系统。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;  <span class="comment">// target 为组件的 data 返回的对象</span></span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用Proxy代理的缺点：</p><ul><li>原始值的响应式系统的实现（proxy 的使用本身就是对于 对象的拦截，导致必须将他包装为一个对象， 通过<code>.value</code>的方式访问</li><li>ES6 解构，不能随意使用。会破坏他的响应式特性</li><li>不兼容IE</li></ul><h3 id="vue3相对vue2的优点"><a href="#vue3相对vue2的优点" class="headerlink" title="vue3相对vue2的优点"></a>vue3相对vue2的优点</h3><ul><li><p>diff算法的优化:</p><p>vue2中的虚拟dom是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）。</p><p>vue3新增了静态标记（<code>patchflag</code>）与上次虚拟节点对比时，只对比带有patch flag的节点（动态数据所在的节点）；可通过flag信息得知当前节点要对比的具体内容。</p></li><li><p>hoistStatic 静态提升:</p><p>vue2无论元素是否参与更新，每次都会重新创建然后再渲染。</p><p>vue3对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。</p></li><li><p>cacheHandlers 事件侦听器缓存:</p><p>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。</p></li><li><p>ssr渲染</p></li><li><p>更好的Ts支持</p></li><li><p>Composition API</p></li><li><p>支持多根节点组件</p></li><li><p>自定义渲染API</p></li><li><p>速度更快，性能更好</p></li></ul><h3 id="Diff算法-1"><a href="#Diff算法-1" class="headerlink" title="Diff算法"></a>Diff算法</h3><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>Vue2 中是通过 Observer，Dep，Watcher 这三个类来实现依赖收集。</p><p>Vue3 中是通过 track 收集依赖，通过 trigger 触发更新，本质上就是用 WeakMap，Map，Set 来实现。</p><h3 id="defineProperty-和-Proxy"><a href="#defineProperty-和-Proxy" class="headerlink" title="defineProperty 和 Proxy"></a>defineProperty 和 Proxy</h3><ul><li>Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法</li><li>defineProperty 不能监听到数组下标变化和对象新增属性，Proxy 可以</li><li>defineProperty 是劫持对象属性，Proxy 是代理整个对象</li><li>defineProperty 局限性大，只能针对单属性监听，所以在一开始就要全部递归监听。Proxy 对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能提升很大，且首次渲染更快</li><li>defineProperty 会污染原对象，修改时是修改原对象，Proxy 是对原对象进行代理并会返回一个新的代理对象，修改的是代理对象</li><li>defineProperty 不兼容 IE8，Proxy 不兼容 IE11</li></ul><h2 id="Vue3和Vue2的区别"><a href="#Vue3和Vue2的区别" class="headerlink" title="Vue3和Vue2的区别"></a>Vue3和Vue2的区别</h2><ul><li>响应式原理</li><li>生命周期钩子名称</li><li>自定义指令钩子名称</li><li>新的内置组件</li><li>diff 算法</li><li>Composition API</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a></p><p><a href="https://blog.csdn.net/lishanleilixin/article/details/79360244" target="_blank" rel="noopener">深入理解vue</a></p><p><a href="https://blog.csdn.net/m6i37jk/article/details/78140159" target="_blank" rel="noopener">深入Vue2.x的虚拟DOM diff原理</a></p><p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noopener">20分钟吃透Diff算法核心原理</a></p><p><a href="https://segmentfault.com/a/1190000040695447" target="_blank" rel="noopener">vue3，对比 vue2 有什么优点？</a></p>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>几道有意思的js题</title>
    <url>/2018/04/16/%E5%87%A0%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84js%E9%A2%98/</url>
    <content><![CDATA[<p>今天看文档发现一个有点意思的题目：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> x;</span><br><span class="line">	alert(x);</span><br><span class="line">	&#125;)(<span class="number">1</span>+<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>最开始我以为答案是undefined，但文档上的答案令我百思不得其解：“函数参数无法 delete 删除， delete 只能删除通过 for in 访问的属性。删除失败也不会报错，所以代码运行会弹出 1”。delete不能删除那么答案也应该是 6 呀，然后我测试了一下果然是6 &#x3D; &#x3D;</p><p>这种题目平常可能很难用上，不过考验一下基础概念应该还是很有趣的。于是我又找了一些类似的题目瞅瞅：</p><a id="more"></a><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>答案：’object’<br>解释：考验对typeof和arguments的理解。arguments 是对象,并且typeof [1,2] &#x3D;&#x3D; ‘object’</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">23</span>; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> g();</span><br></pre></td></tr></table></figure><p>答案：js报错<br>解释：考验函数的声明方法。因为函数g未定义。在 JS 里，声明函数只有 2 种方法：</p><p>第 1 种： function foo(){…} （函数声明）</p><p>第 2 种： var foo &#x3D; function(){…} （等号后面必须是匿名函数，这句实质是函数表达式）</p><p>此处g是函数名，然而第一行不是一个函数声明，因此函数名g仅能在该函数内部被访问到，外部访问不到。</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>, x = y = <span class="keyword">typeof</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>答案：undefined<br>解释：考验赋值运算。先将 typeof x 赋值给 y ，此时 x 未定义，故为 “undefined”，最后将 y 的值赋给 x</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> f();</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;);</span><br></pre></td></tr></table></figure><p>这道题让我逻辑混乱了都&#x3D; &#x3D;</p><p>答案：number<br>解释：在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 “number”，相当于：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.baz; &#125;,</span><br><span class="line">    baz: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;)(foo.bar);</span><br></pre></td></tr></table></figure><p>答案：undefined<br>解释：考验this的指向。这里的 this 指的是 arguments</p><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">   bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.baz; &#125;,</span><br><span class="line">   baz: <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> (f = foo.bar)());</span><br></pre></td></tr></table></figure><p>这道题没弄懂感觉和上一道有点类似&#x3D; &#x3D;</p><p>答案：undefined<br>解释：考验this。因为CallExpression是不带有上下文信息，this会指向global；当你以foo.bar() 调用时，被调用的function是「MemberExpression」，而如果进行了f&#x3D;foo.bar()赋值之后，那么function就会变成「CallExpression」了，因此this绑定就失效了。</p><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">"1"</span>; &#125;, <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br></pre></td></tr></table></figure><p>答案：number<br>解释：f&#x3D;2。只有最后面的函数会被执行。逗号除了作为分隔符，也是一个操作符，总是返回最后一项。例如：var num &#x3D; (1,2,3,4) &#x2F;&#x2F; num&#x3D;4</p><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;) &#123;</span><br><span class="line"> x += <span class="keyword">typeof</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>答案：1undefined<br>解释：括号内的 function f(){} 不是函数声明，会被转换成 true （只有””（空字符串）、0、NaN、null、undefined的布尔值是false），因此 f 未定义。如何判断是否是函数声明：function这个关键词之前有任何东西，那么这都不是一个函数声明，而是函数表达式。</p><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="keyword">typeof</span> x, <span class="keyword">typeof</span> y][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> x);</span><br></pre></td></tr></table></figure><p>答案：string<br>解释：第一行执行完后 x &#x3D;&#x3D;&#x3D; “undefined” ，所以连续求 2 次 typeof 还是 “string”</p><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><p>答案：2<br>解释：由于声明提升，后面的 f() 会覆盖前面的 f()。function声明和var声明不同，var声明对于重复的声明是忽略的，而function声明则是覆盖。</p><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="function"><span class="keyword">function</span>(<span class="params">x, undefined</span>)</span>&#123;&#125;) length;</span><br></pre></td></tr></table></figure><p>答案：2<br>解释：with 限定了作用域是这个函数，function.length 返回函数的参数个数，所以是 2。<br>undefined 虽然是关键词，但可以被覆写。但 null 不能。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.zhihu.com/question/34079683/answer/57863909" target="_blank" rel="noopener">https://www.zhihu.com/question/34079683/answer/57863909</a></p>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端参考博客和在线工具合集</title>
    <url>/2018/08/01/%E5%89%8D%E7%AB%AF%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&mid=2652973793&idx=1&sn=82419c590579b4013606a39392492c17&scene=21#wechat_redirect" target="_blank" rel="noopener">前端技能图谱</a></p><a id="more"></a><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li><a href="http://www.cnblogs.com/2050/p/3392803.html" target="_blank" rel="noopener">CSS布局奇淫技巧之–各种居中</a></li><li><a href="http://caibaojian.com/flexbox-guide.html" target="_blank" rel="noopener">弹性盒模型</a></li><li><a href="https://www.cnblogs.com/moedong/p/6645483.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener">一些实用而又记不住的css技巧</a></li><li><a href="https://www.jb51.net/css/467226.html" target="_blank" rel="noopener">20个非常实用的CSS技巧</a></li></ul><h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><ul><li><a href="https://blog.csdn.net/gertyy/article/details/53637951" target="_blank" rel="noopener">Canvas API 详解</a></li><li><a href="https://segmentfault.com/p/1210000010536257/read" target="_blank" rel="noopener">一个少女心满满的例子带你入门 canvas</a></li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li><a href="https://blog.csdn.net/awp0011/article/details/46801111" target="_blank" rel="noopener">【探秘ES6】系列专栏</a></li></ul><h2 id="可视化-D3"><a href="#可视化-D3" class="headerlink" title="可视化(D3)"></a>可视化(D3)</h2><ul><li><a href="http://d3.decembercafe.org/" target="_blank" rel="noopener">Learning D3.JS</a></li><li><a href="https://www.kancloud.cn/wizardforcel/d3-api-ref/101209" target="_blank" rel="noopener">D3.js API 中文手册</a></li><li><a href="https://blog.csdn.net/yc_1993/article/details/51439365" target="_blank" rel="noopener">Echarts个人轨迹可视化实现</a></li><li><a href="http://www.hightopo.com/demos/index.html" target="_blank" rel="noopener">图拓</a></li><li><a href="https://github.com/d3/d3" target="_blank" rel="noopener">d3</a></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html#lookaround" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><a href="https://www.cnblogs.com/moqiutao/p/8017340.html" target="_blank" rel="noopener">vue开发常见知识点及问题资料整理</a></li><li><a href="https://www.jianshu.com/p/99ee699c7c21" target="_blank" rel="noopener">Vue 知识点整理</a></li><li><a href="https://www.cnblogs.com/alice-fee/p/8664508.html" target="_blank" rel="noopener">Vue 相关难点</a></li><li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">Vue.js源码分析</a></li></ul><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul><li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">《Node.js 包教不包会》 by alsotang</a></li><li><a href="http://www.cnblogs.com/myzhibie/p/4458584.html" target="_blank" rel="noopener">快速使用node.js进行web开发</a></li></ul><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><ul><li><a href="https://www.jianshu.com/p/f0bffc42c1ce" target="_blank" rel="noopener">nodejs前端模板引擎swig入门</a></li><li><a href="https://www.jianshu.com/p/e2a9cd3b7e56" target="_blank" rel="noopener">Jade模板</a></li><li><a href="https://www.cnblogs.com/DCL1314/p/7732696.html" target="_blank" rel="noopener">ejs模板引擎</a></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><ul><li><a href="https://juejin.im/post/5c8f8e62e51d456a0f23d0fe" target="_blank" rel="noopener">Flutter快速上手指南</a></li><li><a href="https://book.flutterchina.club/" target="_blank" rel="noopener">Flutter实战</a></li><li><a href="https://juejin.im/post/5b2869e66fb9a00e5f3e861f" target="_blank" rel="noopener">[译] Awesome Flutter：带你从入门到进阶的 Flutter 指南</a></li></ul><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul><li><a href="https://zhaoda.net/webpack-handbook/index.html" target="_blank" rel="noopener">Webpack 中文指南</a></li><li><a href="https://juejin.im/post/5ae919eb518825670e5cdc90" target="_blank" rel="noopener">只要这几步，webpack速成不是事儿</a></li><li><a href="https://array_huang.coding.me/webpack-book/chapter0/preface.html" target="_blank" rel="noopener">webpack多页应用架构专题系列</a></li><li><a href="https://webpack.wuhaolin.cn/" target="_blank" rel="noopener">深入浅出 Webpack</a></li><li><a href="https://juejin.im/post/5badd0c5e51d450e4437f07a" target="_blank" rel="noopener">Webpack揭秘——走向高阶前端的必经之路</a></li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/" target="_blank" rel="noopener">TypeScript Handbook（中文版）</a></li></ul><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><ul><li><a href="http://www.runoob.com/w3cnote/moible-web-front-source.html" target="_blank" rel="noopener">移动WEB前端开发资源整合</a></li><li><a href="https://blog.csdn.net/u013778905/article/details/70768958/" target="_blank" rel="noopener">从零开始学习移动端Web开发</a></li><li><a href="https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/index.html" target="_blank" rel="noopener">利用视口单位实现适配布局</a></li></ul><h2 id="hexo搭建博客"><a href="#hexo搭建博客" class="headerlink" title="hexo搭建博客"></a>hexo搭建博客</h2><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">手把手教你用Hexo+Github 搭建属于自己的博客</a></li><li><a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a></li><li><a href="https://guanqr.com/tech/website/hexo-theme-next-customization" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li></ul><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><ul><li><a href="https://www.cnblogs.com/summary-2017/p/8073225.html" target="_blank" rel="noopener">详细的Android SDK下载安装及配置教程</a></li><li><a href="https://www.cnblogs.com/pengjunhao/p/6803606.html" target="_blank" rel="noopener">通过cordova将vue项目打包为webapp</a></li></ul><h2 id="插件库"><a href="#插件库" class="headerlink" title="插件库"></a>插件库</h2><ul><li><a href="https://www.jquerycards.com/" target="_blank" rel="noopener">jquery cards</a></li><li><a href="https://codepen.io/pens/#" target="_blank" rel="noopener">codepen</a></li><li><a href="http://www.jq22.com/" target="_blank" rel="noopener">jquery 插件库</a></li><li><a href="http://dynamicsjs.com/" target="_blank" rel="noopener">Dynamics.js</a></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul><li><a href="https://www.cnblogs.com/lihuanqing/p/8533552.html" target="_blank" rel="noopener">js单元测试框架对比</a></li></ul><h2 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h2><ul><li><a href="https://www.jianshu.com/p/8a62b1a2fd75" target="_blank" rel="noopener">Dart 语言简易教程</a></li></ul><h2 id="Guns"><a href="#Guns" class="headerlink" title="Guns"></a>Guns</h2><ul><li><a href="https://blog.csdn.net/lhakuma/article/details/80992352" target="_blank" rel="noopener">从零开始部署Guns V4.0 (SpringBoot开源框架)教程</a></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><a href="https://leetcode-cn.com/?utm_source=LCUS&utm_medium=ip_redirect_o_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">LeetCode</a></li><li><a href="https://www.lintcode.com/" target="_blank" rel="noopener">LintCode</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://tool.lu/timestamp/" target="_blank" rel="noopener">在线工具</a></li><li><a href="http://www.bejson.com/" target="_blank" rel="noopener">在线JSON校验格式化工具</a></li><li><a href="https://www.designrush.com/resources/css3.me" target="_blank" rel="noopener">CSS3 Code Generator</a></li><li><a href="http://screensiz.es/phone" target="_blank" rel="noopener">screen size</a></li><li><a href="http://cssanimate.com/" target="_blank" rel="noopener">CSS Animate</a></li><li><a href="http://caniuse.com/" target="_blank" rel="noopener">查看兼容性</a></li><li><a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">Css sprite在线生成</a></li><li><a href="http://jsfiddle.net/" target="_blank" rel="noopener">在线调试工具</a></li></ul><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li><a href="http://hao.shejidaren.com/" target="_blank" rel="noopener">设计导航 - 精选最好的设计网站大全</a></li><li><a href="https://devdocs.io/" target="_blank" rel="noopener">DevDocs API Documentation</a></li><li><a href="https://coderbyte.com/" target="_blank" rel="noopener">Coderbyte</a></li><li><a href="http://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a></li><li><a href="http://699pic.com/" target="_blank" rel="noopener">摄图网</a></li><li><a href="https://www.cnblogs.com/buzhiqianduan/p/7620099.html" target="_blank" rel="noopener">electron入门心得</a></li><li><a href="https://itbilu.com/other/relate/Ek5ePdjdX.html" target="_blank" rel="noopener">Blockly(可视化编程工具)的配置</a></li></ul>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>红宝书的笔记2</title>
    <url>/2019/01/21/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><a id="more"></a><p>nodeType值为3，nodeName为#text，nodeValue是包含的文本。</p><ul><li><p>doucment.createTextNode(str)：创建新的文本节点</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(<span class="string">"hello"</span>);</span><br><span class="line">ele.appendChild(textnode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者再添加一个文本节点(同胞节点)</span></span><br><span class="line"><span class="keyword">var</span> textnode2 = <span class="built_in">document</span>.createTextNode(<span class="string">" world"</span>);</span><br><span class="line">ele.appendChild(textnode2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ele);</span><br></pre></td></tr></table></figure></li><li><p>normalize()：合并目标下所有文本节点</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上一段的基础上</span></span><br><span class="line"><span class="built_in">console</span>.log(ele.childNode.length); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">ele.normalize();</span><br><span class="line"><span class="built_in">console</span>.log(ele.childNode.length); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(ele.firstNode.nodeValue); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure></li><li><p>splitText(index)：分割文本节点，按照指定位置分割成两个文本节点</p></li></ul><h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><p>nodeType值为8，nodeName为#comment，nodeValue是注释的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"a comment"</span>);</span><br><span class="line"><span class="comment">//创建一个&lt;!-- a comment--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h4><p>nodeType值为2，nodeName为特性的名称，nodeValue是特性的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">'align'</span>);</span><br><span class="line">attr.value = <span class="string">'left'</span>;</span><br><span class="line">element.setAttributeNode(attr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(element.attributes[<span class="string">"align"</span>].value);</span><br><span class="line"><span class="built_in">console</span>.log(element.getAttributeNode[<span class="string">"align"</span>].value);</span><br><span class="line"><span class="built_in">console</span>.log(element.getAttribute[<span class="string">"align"</span>]);</span><br><span class="line"><span class="comment">//left</span></span><br></pre></td></tr></table></figure><h4 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态引入外部脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">  script.src = url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态加载行内脚本</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"function say()&#123;alert('hi');&#125;"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">  <span class="comment">//script.text = str;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//兼容ie和safari</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    script.appendChild(<span class="built_in">document</span>.createTextNode(str));</span><br><span class="line">  &#125;<span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    script.text = str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h4><p>和动态脚本类似。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入外部style</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyle</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">  link.type = <span class="string">'text/css'</span>;</span><br><span class="line">  link.rel = <span class="string">'stylesheet'</span>;</span><br><span class="line">  link.href = url;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h4><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h3><h4 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector()方法"></a>querySelector()方法</h4><p>接收一个css选择符，返回匹配的第一个元素或者 null。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.querySelector(<span class="string">'#mydiv'</span>);</span><br><span class="line"><span class="keyword">var</span> img = mydiv.querySelector(<span class="string">'img.button'</span>);</span><br></pre></td></tr></table></figure><h4 id="querySelectorAll-方法"><a href="#querySelectorAll-方法" class="headerlink" title="querySelectorAll()方法"></a>querySelectorAll()方法</h4><p>返回一个nodelist的实例。和querySelector类似。</p><h4 id="matchesSelector-方法"><a href="#matchesSelector-方法" class="headerlink" title="matchesSelector()方法"></a>matchesSelector()方法</h4><p>检测调用元素与该选择符是否匹配。（部分浏览器不支持）</p><h4 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h4><ul><li>childElementCount：返回子元素的个数</li><li>firstElementChild和lastElementChild：指向第一个子元素&#x2F;最后一个子元素</li><li>previousElementSibling和nextElementSibling：指向前一个兄弟元素&#x2F;后一个兄弟元素</li></ul><h4 id="html5相关"><a href="#html5相关" class="headerlink" title="html5相关"></a>html5相关</h4><ol><li>getElementsByClassName()</li></ol><p>接收一个或多个类名的字符串，返回nodelist。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'username current'</span>);</span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>).getElementsByClassName(<span class="string">'selected'</span>);</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p>classList属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.classList.remove(<span class="string">'classA'</span>).add(<span class="string">'classB'</span>).toggle(<span class="string">'classC'</span>);</span><br><span class="line"><span class="comment">//div移除类classA 添加classB 切换classC</span></span><br><span class="line"><span class="comment">//判断元素是否包含类名</span></span><br><span class="line"><span class="keyword">if</span>(div.classList.contains(<span class="string">'classA'</span>) &amp;&amp; !div.classList.contains(<span class="string">'classB'</span>))&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>焦点管理</p></li></ol><p>document.activeElement 属性：引用DOM中当前聚焦元素。默认情况下文档加载完时保存的是document.body，文档加载期间是null</p><p>document.hasFocus()：判断是否聚焦<br>4. HTMLdocument扩展</p><p>document.readyState：loading正在加载文档；complete加载完成</p><p>document.compatMode：CSS1Compat标准模式；BackCompat混杂模式</p><p>document.charset和document.defaultCharset：文档使用的字符集<br>5. 插入标记</p><p>window.toStticHTML()：传入html字符串，返回删除所有脚本节点和事件处理属性的html字符串</p><p>outerHTML()：返回指定元素及其子元素的html标签；或替换指定元素及其子元素</p><p>innerHTML()：返回指定节点的子元素；或替换子元素</p><p>insertAdiacentHTML()：参数传插入位置（beforebegin&#x2F;afterbegin&#x2F;beforeend&#x2F;afterend）和插入的html文本。<br>6. 其他扩展</p><p>parentNode.contains(node)：检测该节点是否是后代节点</p><p>innerText()：返回指定元素文档树中的文本；或插入文本替换指定元素的所有子节点</p><p>scrollIntoView()：滚动</p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">div.style.backgroundColor = <span class="string">'green'</span>;</span><br></pre></td></tr></table></figure><p>DOM样式属性和方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置</span></span><br><span class="line">div.style.cssText = <span class="string">"width:100px;height:100px;background:blue;"</span>;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = div.style.length; i &lt; len; i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> prop = div.style[i];<span class="comment">//属性名</span></span><br><span class="line">  <span class="keyword">var</span> value = div.style.getPropertyValue(prop);<span class="comment">//属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">div.style.removePropery(<span class="string">'width'</span>);</span><br></pre></td></tr></table></figure><p>计算属性(只读)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取完整的属性（包括&lt;style&gt;样式表中的属性）</span></span><br><span class="line"><span class="keyword">var</span> computeStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(div,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//第二个参数可以传伪元素字符串（":after"）</span></span><br><span class="line"><span class="built_in">console</span>.log(computeStyle.border);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ie中不支持getComputedStyle()</span></span><br><span class="line"><span class="keyword">var</span> computeStyle = div.currentStyle;<span class="comment">//ie</span></span><br><span class="line"><span class="built_in">console</span>.log(computeStyle.border);</span><br></pre></td></tr></table></figure><h4 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h4><p>css规则：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取样式表中的css</span></span><br><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.styleSheet[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> rules =sheet.cssRules || sheet.rules;</span><br><span class="line"><span class="keyword">var</span> rule = yules[<span class="number">0</span>]; <span class="comment">//获取第一条规则</span></span><br><span class="line"><span class="built_in">console</span>.log(rule.style.cssText);</span><br><span class="line"><span class="built_in">console</span>.log(rule.style.width);</span><br><span class="line"></span><br><span class="line">rule.style.backgroundColor = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">sheet.insertRule(<span class="string">"body&#123;background:#f6f6f6&#125;"</span>,<span class="number">0</span>);<span class="comment">//插入规则，插入位置</span></span><br><span class="line">sheet.addRule(<span class="string">"body"</span>,<span class="string">"background:#f6f6f6"</span>,<span class="number">0</span>);<span class="comment">//ie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">sheet.deleteRule(<span class="number">0</span>);</span><br><span class="line">sheet.removeRule(<span class="number">0</span>);<span class="comment">//ie</span></span><br></pre></td></tr></table></figure><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><p>偏移量</p><ul><li>offsetHeight：元素在垂直方向占用的空间（border+padding+content）</li><li>offsetWidth：元素在水平方向占用的空间</li><li>offsetLeft：元素的左外边框至父元素的左内边框的距离</li><li>offsetTop：元素的上外边框至父元素的上内边框的距离</li></ul><p>客户区大小：</p><p>clientHeight &#x3D; height + paddingTop + paddingBottom</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浏览器的视口大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'BackCompat'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width:<span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">      height:<span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width:<span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">      height:<span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动大小：</p><ul><li>scrollHeight：在没有滚动条时的元素内容总高度</li><li>scrollWidth：在没有滚动条时的元素内容总宽度</li><li>scrollTop：滚动高度</li><li>scrollLeft：横向滚动距离</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ol><li><p>NodeIterator</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.tagname.toLowerCase() == <span class="string">'p'</span> ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(root,NodeFilter.SHOW_ELEMENT,filter,<span class="literal">false</span>);</span><br><span class="line"> <span class="comment">//创建实例(遍历的根节点，显示的节点类型，过滤器，是否扩展实体引用)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node = iterator.nextNode(); <span class="comment">//指向下一个节点</span></span><br><span class="line"><span class="comment">//var node = iterator.previousNode();</span></span><br><span class="line"><span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node.tagName); <span class="comment">//输出标签名</span></span><br><span class="line">  node = iterator.nextNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeWalker</p></li></ol><p>document.createTreeWalker()和document.createNodeIterator方法类似，因此TreeWalker可以代替NodeIterator。TreeWalker可以在DOM结构中沿任何方向移动。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = documnet.getElementById(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> waiker = <span class="built_in">document</span>.createTreeWalker(div,NodeFilter.SHOW_ELEMENT,<span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">walker.firstChild(); <span class="comment">//当前节点的第一个子节点</span></span><br><span class="line">walker.nextSibling(); <span class="comment">//下一个兄弟节点</span></span><br><span class="line"><span class="comment">//walker.previousSibling(); //上一个兄弟节点</span></span><br><span class="line"><span class="comment">//walker.parentNode(); //当前节点的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node = walker.firstChild();</span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node.tagName);</span><br><span class="line">  <span class="built_in">console</span>.log(node === walker.currentNode);</span><br><span class="line">  <span class="comment">//currentNode表示上一次遍历中返回的节点，通过这个属性可以修改下次遍历的起点</span></span><br><span class="line">  node = walker.nextSibling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>简单选择：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">range2 = <span class="built_in">document</span>.createRange();</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById();</span><br><span class="line"></span><br><span class="line">range1.selectNode(div); <span class="comment">//选择整个节点及其子节点</span></span><br><span class="line">range2.selectNodeContents(div); <span class="comment">//选择该节点下的子节点</span></span><br></pre></td></tr></table></figure><p>复杂选择：</p><p>借助setStart()和setEnd()可以选择节点的一部分。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> hello = p.firstChild.firstChild,</span><br><span class="line">  world = p.lastChild;</span><br><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line">range.setStart(hello,<span class="number">2</span>);</span><br><span class="line">range.setEnd(world,<span class="number">3</span>);<span class="comment">//选择范围</span></span><br></pre></td></tr></table></figure><p>操作选区：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接上</span></span><br><span class="line">range.deleteContent();<span class="comment">//删除选区</span></span><br><span class="line"><span class="keyword">var</span> fragment = range.extractContents(); <span class="comment">//删除选区,返回范围的文档片段</span></span><br><span class="line"><span class="keyword">var</span> clonement = range.cloneContents(); <span class="comment">//创建范围的一个副本</span></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是用户或浏览器自身执行的某种动作。</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件开始时由最具体的元素接收然后逐级向上传播。</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获是不具体的节点更早接收事件，然后往下传播到最具体的点。</p><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p>响应某个事件的函数。</p><ol><li><p>DOM0级事件处理程序</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//事件处理程序在所属元素的作用域内运行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>DOM2级事件处理程序</p></li></ol><p>addEventListener()：传递3个参数，要处理的事件名，函数，true(事件捕获)&#x2F;false(事件冒泡)<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"click!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);<span class="comment">//事件按顺序触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,func,<span class="literal">false</span>);<span class="comment">//匿名函数才能移除</span></span><br><span class="line">btn.removeEventListener(<span class="string">"click"</span>,func,<span class="literal">false</span>);<span class="comment">//移除事件</span></span><br></pre></td></tr></table></figure><p></p><ol start="3"><li>IE事件处理程序<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//事件处理程序在全局作用域中运行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"click2"</span>); <span class="comment">//true</span></span><br><span class="line">&#125;,<span class="literal">false</span>);<span class="comment">//按照相反的顺序执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>,func);<span class="comment">//匿名函数才能移除</span></span><br><span class="line">btn.detachEvent(<span class="string">"onclick"</span>,func);<span class="comment">//移除事件</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><h5 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在事件处理程序内部，对象this等于event.currentTarget。而event.target只包含事件的实际目标。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;<span class="comment">//直接将事件处理程序指定给目标程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget === <span class="keyword">this</span>);<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.target === <span class="keyword">this</span>);<span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>处理多个事件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.target.style.color = <span class="string">'red'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.target.style.color = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure><p>其他：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.preventDefault();<span class="comment">//阻止特定事件的默认行为</span></span><br><span class="line"></span><br><span class="line">  event.stopPropagation();<span class="comment">//阻止事件冒泡或捕获</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(event.eventPhase);</span><br><span class="line">  <span class="comment">//确定事件处于事件流的哪个阶段</span></span><br><span class="line">  <span class="comment">//1 在捕获阶段调用</span></span><br><span class="line">  <span class="comment">//2 事件处理程序处于目标上</span></span><br><span class="line">  <span class="comment">//3 在冒泡阶段调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="IE的事件对象"><a href="#IE的事件对象" class="headerlink" title="IE的事件对象"></a>IE的事件对象</h5><p>事件处理程序的作用域是根据指定他的方式来确定的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//ie不支持事件捕获 因此只能阻止事件冒泡</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>; <span class="comment">//阻止事件默认行为</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.srcElement === <span class="keyword">this</span>); <span class="comment">//false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="跨浏览器事件"><a href="#跨浏览器事件" class="headerlink" title="跨浏览器事件"></a>跨浏览器事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHander:<span class="function"><span class="keyword">function</span>(<span class="params">elem,type,handler</span>)</span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent:funtion(event)&#123;</span><br><span class="line">    <span class="keyword">return</span> event? event:<span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target|| event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//ie</span></span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">elem,type,handler</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getRelatedTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//只有mouseout 和mouseover有相关元素</span></span><br><span class="line">    <span class="keyword">if</span>(event.relatedTarget)&#123;</span><br><span class="line">      <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.toElement)&#123;</span><br><span class="line">      <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.fromElement)&#123;</span><br><span class="line">      <span class="keyword">return</span> event.fromElement;</span><br><span class="line">    &#125;eles&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//确定浏览器是否支持DOM3级事件</span></span><br><span class="line"><span class="keyword">var</span> supprot = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"UIEvent"</span>,<span class="string">"3.0"</span>);</span><br></pre></td></tr></table></figure><ol><li>load : 页面完全加载后（包括外部资源加载完成后）触发</li><li>unload : 文档被完全卸载后触发（从一个页面切换到另一个页面）。</li><li>resize : 当窗口或者框架大小变化时触发</li><li>scroll : 窗口或元素滚动时触发</li><li>abort : 停止下载时，嵌入的内容没有加载完在object上触发</li><li>error : 发生错误时</li><li>select : 选择文本框中的字符时</li><li>blur&#x2F;focusout : 失焦(不冒泡&#x2F;冒泡)</li><li>focus&#x2F;focusin : 聚焦</li><li>click : 单击(左键)或按下回车</li><li>dblclick : 双击（左键）</li><li>mousedown : 按下任意鼠标</li><li>mouseenter : 首次移动到元素范围内触发</li><li>mouseleave : 移到元素范围外</li><li>mousemove : 在元素内部移动时重复触发</li><li>mouseout : 移到另一个元素</li><li>mouseover : 鼠标在一个元素外部，首次移入另一个元素</li><li>mouseup : 释放鼠标按钮触发</li><li>mousewheel : 鼠标滚轮事件</li><li>keydown : 按键盘任意键触发，按住不放会重复触发</li><li>keypress : 按键盘字符键触发，按住不放会重复触发</li><li>keyup : 释放按键触发</li><li>textInput : 文本框输入</li></ol><h5 id="事件位置"><a href="#事件位置" class="headerlink" title="事件位置"></a>事件位置</h5><ul><li>event.clientX&#x2F;Y : 鼠标事件在客户端坐标信息</li><li>pagaX&#x2F;Y : 在页面中的坐标</li><li>screenX&#x2F;Y : 相对浏览器的位置</li></ul><h5 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h5><ol><li>contextmenu : 自定义显示上下文菜单（如点击鼠标右键）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>);</span><br><span class="line">EventUtil.addHandler(div,<span class="string">"contextmenu"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">"mymenu"</span>);</span><br><span class="line">  menu.style.left = event.clientX+<span class="string">"px"</span>;</span><br><span class="line">  menu.style.top = event.clientY+<span class="string">"px"</span>;</span><br><span class="line">  menu.style.visibility = <span class="string">"visible"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">EventUtil.addHander(<span class="built_in">document</span>,<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"mymenu"</span>).style.visibility = <span class="string">"hidden"</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>beforeunload : 页面卸载前触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"beforeunload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="string">"确定关闭？"</span>;</span><br><span class="line">    event.returnValue = msg;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>DOMContentLoaded : 页面load时形成完整的DOM树就触发，在load前触发</p></li><li><p>readystatechange ：提供文档或元素有关的加载信息</p></li><li><p>pageshow和pagehide : （往返缓存有关，有些浏览器回退页面时不触发load）在页面显示时触发，一般在load之后；pagehide是在卸载页面时触发，在unload前触发；event保存属性persisted判断页面是否是回退的（在bfcache中）</p></li><li><p>haschange : 在url参数变化时触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"beforeunload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"current hash:"</span>+location.hash)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h5 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h5><ul><li>orientationchange : （苹果safari）设备切换（横纵）方向时触发；window.orientation属性中保存当前旋转角度</li><li>MozOrientation : （firefox）设备方向改变</li><li>deviceorientation : 设备方向改变</li><li>devicemotion : 包含设备的运动信息</li></ul><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><ul><li>touchstart : 当手指触摸屏幕时</li><li>touchmove : 手指在屏幕上滑动时连续触发。期间调用preventDefault()可以阻止滚动</li><li>touchend : 手指从屏幕移开</li><li>touchcancel : 当系统停止跟踪触摸</li></ul><p>以上事件都是冒泡的，也都是可以取消的。包含用于跟踪触摸的属性：</p><ul><li>touches : 表示当前跟踪触摸的对象数组</li><li>targetTouchs : 特定于事件目标的Touch对象的数组</li><li>changeTouches : 表示从上次触摸以来改变了的对象的数组</li></ul><p>顺序：touchstart - mouseover - mousemove - mousedown - mouseup - click - touchend</p><p>手势事件：只有两个手指都触摸时才会触发</p><ul><li>getsturestart : 当一个手指按在屏幕而另一个手指又触摸屏幕</li><li>getsturechange : 当触摸屏幕的手指位置变化</li><li>getstureend : 当手指移开屏幕</li></ul><h4 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h4><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>在js中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行。因此需要事件委托，事件委托利用了事件冒泡，只指定一个事件处理程序管理某一类型的事件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = doucment.getElementById(<span class="string">"links"</span>);</span><br><span class="line">EventUtil.addHandler(list,<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e = EventUtil.getEvent(e);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(e);</span><br><span class="line">  <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"li1"</span>:</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">'aaa'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"li2"</span>:</span><br><span class="line">      location.herf = <span class="string">'index.html'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>PS: 当事件处理程序指定给元素时，浏览器代码和脚本就会建立连接，这种连接越多页面越慢。除了利用事件委托还可以移除无用的事件处理程序来提升性能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  btn.onclick = <span class="literal">null</span>; <span class="comment">//移除事件处理程序</span></span><br><span class="line">  doucment.getElementById(<span class="string">"btnParent"</span>).innerHTML = <span class="string">"Processing..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h5><p>可以在任何时候触发模拟事件，可用来测试web程序。模拟事件也可以冒泡。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟鼠标事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = doucment.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>,<span class="literal">true</span>,<span class="literal">true</span>,doucment.defaultView,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h3 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h3><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取表单</span></span><br><span class="line"><span class="keyword">var</span> forms = <span class="built_in">document</span>.forms;</span><br><span class="line"><span class="keyword">var</span> firstForm = forms[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> myForm = forms[<span class="string">"form2"</span>];<span class="comment">//name = form2</span></span><br></pre></td></tr></table></figure><ol><li>提交表单</li></ol><p>表单中包含button&#x2F;input，type&#x3D;”submit”或者type&#x3D;”image”(图片按钮)，点击或enter可提交表单。</p><p>form.submit()提交表单时不会触发submit事件，所以在此之前要先验证表单数据。<br>2. 重置表单</p><p>input&#x2F;button，type&#x3D;”reset”可以重置表单。form.reset()会触发reset事件。<br>3. 表单字段<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"form1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//表单的第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取表单中name="field2"的字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"field2"</span>];</span><br></pre></td></tr></table></figure><p></p><p>表单字段属性：<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myform"</span>);</span><br><span class="line"><span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改value属性</span></span><br><span class="line">field.value = <span class="string">"aaa"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查form属性</span></span><br><span class="line"><span class="built_in">console</span>.log(field.form == form); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置焦点</span></span><br><span class="line">field.focus();</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用</span></span><br><span class="line">field.disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改type属性（input）</span></span><br><span class="line">feild.type = <span class="string">"text"</span>;</span><br></pre></td></tr></table></figure><p></p>]]></content>
      <categories>
        <category>笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的浏览器存储方式</title>
    <url>/2020/06/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很久很久以前，由于HTTP 协议是一个无状态协议，服务器是无法记录浏览器的状态的。如果每次都要在通过表单提交信息给服务器，或者通过向服务器请求某些固定的数据，这无疑是十分繁琐的事情，因此如何进行状态管理就是急需解决的一个问题。因此cookie就这样诞生啦，在此后的许多年，浏览器发展迅速，出现了更多的存储方式，他们各有优缺点，接下来让我们详细了解下吧！</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie最初是用于存储会话信息的，它会自动随着HTTP请求头信息一起发送，因此服务器就可以获取到cookie中的数据。</p><p>Cookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。</p><h3 id="Cookie的优点"><a href="#Cookie的优点" class="headerlink" title="Cookie的优点"></a>Cookie的优点</h3><ol><li>Cookie相比于其他的数据存储方式，兼容性更好。</li><li>Cookie可以设置过期时间，默认是会话结束时到期自动销毁。</li></ol><h3 id="Cookie的缺点"><a href="#Cookie的缺点" class="headerlink" title="Cookie的缺点"></a>Cookie的缺点</h3><ol><li>Cookie能存储的数据容量有限，最大只能有 4KB，因此Cookie只能用来存少量信息。</li><li>Cookie会被放到统一域名下的所有请求的请求头中，而有些请求并不需要cookie中的数据，因此会增加一部分不必要的网络开销。</li><li>Cookie一般只能存储字符串，存储的格式有限。</li><li>由于Cookie中的键值对是经过URL编码的，所以读取Cookie需要解码，使用不太方便。</li><li>Cookie是使用HTTP连接传递数据，所以 cookie 存储的信息容易被窃取，安全性不高。</li></ol><h3 id="Cookie的用法"><a href="#Cookie的用法" class="headerlink" title="Cookie的用法"></a>Cookie的用法</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">document</span>.cookie.indexOf(name+<span class="string">"="</span>) ;</span><br><span class="line">  <span class="keyword">if</span> ( start != <span class="number">-1</span> )&#123;</span><br><span class="line">      start = start + name.length + <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">var</span> end = <span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>, start) ;</span><br><span class="line">      <span class="keyword">if</span> ( end == <span class="number">-1</span> ) end = <span class="built_in">document</span>.cookie.length ;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">document</span>.cookie.substring(start,end)) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> expdate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="comment">//设置过期时间</span></span><br><span class="line">  expdate.setTime(expdate.getTime() + <span class="number">60</span> * <span class="number">60</span>  * <span class="number">1000</span>);<span class="comment">//1 hour</span></span><br><span class="line">  <span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";expires="</span> + expdate.toUTCString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newVue = <span class="keyword">new</span> Vue();</span><br><span class="line">  newVue.setCookie( name, <span class="literal">null</span>, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStroage是HTML5中新增的浏览器存储机制，它可以作为持久保存客户端数据的方案，除非主动删除localStorage中的数据，否则数据是永远不会过期的。</p><h3 id="localStorage的优点"><a href="#localStorage的优点" class="headerlink" title="localStorage的优点"></a>localStorage的优点</h3><ol><li>localStorage的存储量大。</li><li>localStorage也是以键值对的方式存储字符串，相对于cookie，它可存的数据格式更多。</li><li>localStorage不会与服务端发生通信，仅位于浏览器端。</li></ol><h3 id="localStorage的缺点"><a href="#localStorage的缺点" class="headerlink" title="localStorage的缺点"></a>localStorage的缺点</h3><ol><li>如果要存储JSON格式的数据，存储和获取的时候需要进行JSON和字符串之间的转换，因此它还是更适合存储数据结构较为简单的数据。</li><li>localStorage中的数据没有过期时间设置，不能自动删除，如果存储内容多的话会消耗内存空间。</li></ol><h3 id="localStorage的用法"><a href="#localStorage的用法" class="headerlink" title="localStorage的用法"></a>localStorage的用法</h3><h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.getItem(key)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">localStorage[key]</span><br></pre></td></tr></table></figure><h4 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(key,value);</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.removeItem(key)</span><br><span class="line"><span class="comment">//或者清除所有的数据</span></span><br><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage和localStroage差不多，也是本地存储。但sessionStorage的生命周期和localStroage不同，它是会话级别的本地存储，当会话结束时存储内容就会被销毁。</p><p>Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。</p><h3 id="sessionStorage的用法"><a href="#sessionStorage的用法" class="headerlink" title="sessionStorage的用法"></a>sessionStorage的用法</h3><h4 id="读取-2"><a href="#读取-2" class="headerlink" title="读取"></a>读取</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure><h4 id="写入-2"><a href="#写入-2" class="headerlink" title="写入"></a>写入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(key,value);</span><br></pre></td></tr></table></figure><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.removeItem(key)</span><br><span class="line"><span class="comment">//或者清除所有的数据</span></span><br><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>以上三种都只适用于少量数据，如果要存储更多更复杂的数据就不适用了。因此我们需要新的存储方式，比如IndexedDB。</p><p>IndexedDB 是一个运行在浏览器上的非关系型数据库。</p><p>IndexedDB与 Web storage 一致，均是在创建数据库的域名下才能访问。且不能指定访问域名。IndexedDB存储时间永久，除非用户清除数据，可以用作长效的存储。</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>红宝书的笔记1</title>
    <url>/2019/01/21/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>松散类型，可以保存任何类型的数据。</p><a id="more"></a><h4 id="变量对象-缩写为VO"><a href="#变量对象-缩写为VO" class="headerlink" title="变量对象(缩写为VO)"></a>变量对象(缩写为VO)</h4><p>一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p><ul><li>变量 (var, 变量声明);</li><li>函数声明 (FunctionDeclaration, 缩写为FD);</li><li>函数的形参</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局上下文中的变量对象包含：</span></span><br><span class="line">x <span class="comment">//30</span></span><br><span class="line">bar <span class="comment">//&lt;funciton&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>使用var声明变量但未初始化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a == <span class="string">'undefined'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b == <span class="string">'undefined'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>逻辑上来看相当于空对象指针。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line">cosole.log(<span class="keyword">typeof</span> a);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>该类型只有两个字面值：true&#x2F;false。</p><p>可以通过转型函数<font color="#63ca87">Boolean()</font>将其他类型的值转换为boolean类型。其中转为false的值如下：</p><ul><li>String : ‘’（空字符串）</li><li>Number : 0和NaN</li><li>Object : null</li><li>Undefined : undefined</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ol><li>数值范围</li></ol><p>在ECMAScript中超出了最小值Number.MIN_VALUE或者最大值Number.MAX_VALUE会被转换为Infinity(正无穷)，如果是负数就是-Infinity(负无穷)。</p><p>可以通过<font color="#63ca87">isFinite()</font>判断数值是否有穷。<br>2. NaN</p><p>非数值，表示本来要返回数值的操作数未返回数值的情况。NaN进行任何操作结果都是NaN；NaN和任何值都不相等，包括NaN本身。使用<font color="#63ca87">isNaN</font>判断是否是非数值。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试isNaN()</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'10'</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'blue'</span>);<span class="comment">//true,不能被转化为number</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p></p><ol start="3"><li>数值转化<br>非数值转换为数值：</li></ol><ul><li><p><font color="#63ca87">Number()</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'blue'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'00011'</span>); <span class="comment">//11</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">parseInt()</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1234blue'</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xA'</span>); <span class="comment">//十六进制的10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'070'</span>); <span class="comment">//八进制的56</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xAF'</span>,<span class="number">16</span>); <span class="comment">//175(十六进制)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'AF'</span>,<span class="number">16</span>); <span class="comment">//175(十六进制)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'AF'</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">parseFloat()</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1234blue'</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">22.34</span><span class="number">.5</span>); <span class="comment">//22.34</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">3.125e7</span>); <span class="comment">//31250000</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0xA'</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>转化为字符串：</p><ul><li><p><font color="#63ca87">toString()</font></p><p>ps: null和undefined没有这个方法。<br>默认不传参以十进制输出。也可以传参输出二进制，八进制，十六进制等。</p></li><li><p>转型函数<font color="#63ca87">String()</font></p><p>能够将任何类型的值转化为字符串。</p></li></ul><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>数据和功能的集合。Object的每个实例都具有以下属性和方法：</p><ul><li>constructor : 保存着用于创建当前对象的函数</li><li>hasOwnProperty(pro) : 检测属性是否存在</li><li>isPrototypeOf(obj) : 检测传入的对象是否是当前对象的原型</li><li>propertyIsEnumerable(pro) : 检测属性是否可以用for-in枚举</li><li>toLocaleString() : 返回对象的字符串表示</li><li>toString() : 返回对象的字符串表示</li><li>valueOf() : 返回对象的字符串、数值、布尔值表示</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ol><li>基本类型值指的是简单的数据，按值访问，可以操作保存在变量中的实际值</li><li>引用类型值指的是保存在内存中的对象，按引用访问</li></ol><p>复制引用类型值时，除了会复制变量中的值，而且两个变量引用的是同一对象，改变其中一个变量也会影响另一个变量。</p><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>引用类型的值是引用类型的实例。</p><h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ol><li><font color="#63ca87">push()</font>：接收任意数量的参数，并逐个添加到数组末尾,并返回修改后的数组长度</li><li><font color="#63ca87">pop()</font>：从数组末尾移除最后一项，减少数组长度并返回移除的项</li></ol><h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ol><li><font color="#63ca87">shift()</font>：移除数组第一项并返回该项，数组长度减一</li><li><font color="#63ca87">unshitf()</font>：在数组前端添加任意个数并返回新数组长度</li></ol><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ol><li><font color="#63ca87">reduce()</font>：从数组的第一项开始，逐个遍历到最后</li><li><font color="#63ca87">reduceRight()</font>：从数组的最后一项开始，向前遍历到第一项</li></ol><p>接收一个参数：在每一项调用的函数和作为归并基础的初始值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//传入参数：前一个值，当前值，索引，数组对象</span></span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><p>创建一个日期对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><p>不传递参数时，新建对象自动获得当前时间日期。</p><ul><li><p><font color="#63ca87">Date.parse(date)</font>：接收一个表日期的字符串参数，返回相应毫秒数或者NaN。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25,2004"</span>));</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25,2004"</span>);</span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">Date.UTC()</font>：返回毫秒数,参数是（年份，基于0的月份，日期，小时，分钟，秒），年份和月份是必须的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GMT时间2000-1-1 00:00:00</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//GMT时间2001-2-5 17:55:55</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2001</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">55</span>,<span class="number">55</span>));</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">55</span>,<span class="number">55</span>);</span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">Date.now()</font>：返回调用这个方法的时间毫秒数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><p>将日期格式化为字符串的方法：</p><ul><li>toDateString():显示日期</li><li>toTimeString(): 显示时间</li><li>toLocaleDateString(): 显示地区日期</li><li>toLocaleTimeString(): 显示地区时间</li><li>toUTCString(): 显示UTC日期</li></ul><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>正则式的元字符：( [ { \ ^ $ | ) ? * + . ] }</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.at/g</span>; <span class="comment">//返回以at结尾的字符串</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>, i++)&#123;</span><br><span class="line">  re = <span class="regexp">/cat/g</span>;</span><br><span class="line">  re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;<span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>, i++)&#123;</span><br><span class="line">  re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>,<span class="string">"g"</span>);</span><br><span class="line">  re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><ul><li>. ： 匹配除换行符之外的所有字符</li><li>\d ： 匹配数字，相当于[0-9]</li><li>\w ： 字母或数字或下划线或汉字等</li><li>* ： 表示前边的内容可以连续重复使用任意次数(包括0次)</li><li>\s ： 匹配任意空格符，包括换行符和tab</li><li>\b ： 表示单词的开头或结尾，也就是单词的分界处</li><li>+ ：表示出现至少一次或多次</li><li>\r ：回车</li><li>\t ：制表符，tab</li><li>^ ：匹配字符串的开始</li><li>$ ：匹配字符串结束</li><li>? ：表示出现0次或一次</li><li>{n} ：重复n次</li><li>{n,} ：重复n次或更多次</li><li>{n,m} ：重复n到m次</li><li>\W ：匹配任意不是字母，数字，下划线，汉字的字符</li><li>\S ：匹配任意不是空白符的字符</li><li>\D ：匹配任意非数字的字符</li><li>\B ： 匹配不是单词开头或结束的位置</li><li>[^xy] ：匹配除了xy以外的任意字符</li><li>[\s\S] ：匹配任意字符，[^] 与 [\s\S] 等价</li><li>(?&#x3D;exp) ：零宽度正预测先行断言，断言自身出现的位置的后面能匹配表达式exp</li><li>(?!exp) ：零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp</li><li>(?#comment) ：注释</li><li>.* ：贪婪匹配，匹配尽可能多的字符</li><li>*? ：懒惰匹配，也就是匹配尽可能少的字符,重复任意次</li><li>+? ：重复1次或更多次，但尽可能少重复</li><li>?? ：重复0次或1次，但尽可能少重复</li><li>{n,m}? ：重复n到m次，但尽可能少重复<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = \&lt;(\w+)&gt;\g; <span class="comment">// 查找尖括号括起来的字母或数字(即HTML/XML标签)</span></span><br></pre></td></tr></table></figure></li></ul><p>toLocaleString()和toString()都发挥正则表达式的字面量，与创建表达式的方式无关。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"gi"</span>);</span><br><span class="line">reg.toString(); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li><p><font color="#63ca87">exec(str)</font>: 返回包含第一个匹配性信息的数组或null。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的补货组匹配的字符串。返回的数组有两个额外的属性：<br>index：匹配项在字符串的位置；<br>input：应用正则的字符串；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mon and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mon( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">//"mon and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//"mon and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]); <span class="comment">//"and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]); <span class="comment">//"and baby"</span></span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">test(str)</font>: 测试是否匹配</p></li><li><p><font color="#63ca87">compile()</font>: 对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况</p></li><li><p><font color="#63ca87">str.match(reg)</font>: 输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。</p></li></ul><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>函数是对象。定义函数：函数声明和函数表达式。</p><h4 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h4><ul><li><p>arguments： 保存函数参数，类数组对象。属性callee: 指针，指向拥有这个arguments的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于(严格模式下不支持)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this: 引用的是函数执行的环境对象，当全局调用时，指向的是window</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></li><li><p>caller(ES5): 保存着调用当前函数的函数的引用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">funtion inner()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">  <span class="comment">//指向outer()</span></span><br><span class="line">  <span class="comment">//console.log(arguments.callee.caller);</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h4><p>属性：</p><ul><li>length: 表示函数希望接收的参数个数</li><li>prototype：保存所有的实例方法</li></ul><p>方法：<br>以下两个方法都是在特定的作用域调用函数，实际上等于设置函数体内this对象的值。</p><ul><li><p><font color="#63ca87">apply()</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用1：传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">//this指向window</span></span><br><span class="line">  <span class="comment">//相当于</span></span><br><span class="line">  <span class="comment">// return sum.apply(this,[a,b]);</span></span><br><span class="line">&#125;</span><br><span class="line">callSum(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//30</span></span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">call()</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用1：传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line">callSum(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//30</span></span><br><span class="line"><span class="comment">//作用2：扩充函数运行的作用域</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></li><li><p><font color="#63ca87">bind()</font>: 创建一个函数的实例，this值被绑定到传给bind()函数的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayColorFun = sayColor.bind(o);</span><br><span class="line">sayColorFun(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>用于操作基本类型值的特殊的引用类型：Boolean,Nymber,String</p><p>引用类型和基本包装类型的主要区别就是对象的生存周期。使用new创建的引用类型实例在执行流离开作用域之前一直保存在内存中。自动创建的基本包装类型的对象值存在于一行代码执行的瞬间，然后立即销毁。</p><p>对基本包装类型的实例调用typeof返回object,并且转化为布尔类型时都是true。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据传入的值的类型返回相应的基本包装类型实例</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">'text'</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>使用new调用基本包装类型的构造函数和直接调用转型函数不一样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(value);<span class="comment">//转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);<span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><ul><li><font color="#63ca87">toFixed()</font>: 按指定的小数位返回数值的字符串表示。</li><li><font color="#63ca87">toExponential()</font>: 以指数表示法当数值的字符串形式。参数指定输出结果中的小数位数。</li><li><font color="#63ca87">toPrecision()</font>: 返回最合适的数值格式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">num.toPrecision(<span class="number">1</span>); <span class="comment">//"1e+2"</span></span><br><span class="line">num.toPrecision(<span class="number">2</span>); <span class="comment">//"99"</span></span><br><span class="line">num.toPrecision(<span class="number">3</span>); <span class="comment">//"99.0"</span></span><br></pre></td></tr></table></figure></li></ul><p>不建议实例化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numobj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> numval = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numobj); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numval); <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numobj <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(numval <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h4><p>全局对象</p><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><ol><li><p>min()和max()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">55</span>,<span class="number">22</span>);  <span class="comment">//55</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.apply(<span class="built_in">Math</span>,arr);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>舍入方法</p></li></ol><ul><li><font color="#63ca87">ceil(num)</font>：向上取整</li><li><font color="#63ca87">floor(num)</font>：向下取整</li><li><font color="#63ca87">round(num)</font>：四舍五入</li></ul><ol start="3"><li>其他方法</li></ol><ul><li><font color="#63ca87">random()</font>：返回0到1之间的随机数</li><li><font color="#63ca87">abs(num)</font>：绝对值</li><li><font color="#63ca87">exp(num)</font>：返回Math.E(自然对数的底数，常量e)的num次幂</li><li><font color="#63ca87">log(num)</font>：自然对数</li><li><font color="#63ca87">pow(num,power)</font>：返回num的power次幂</li><li><font color="#63ca87">sqrt(num)</font>：平方根</li><li><font color="#63ca87">acos(num)</font>：反余弦值</li></ul><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h4 id="数据属性："><a href="#数据属性：" class="headerlink" title="数据属性："></a>数据属性：</h4><p>要修改属性默认特性需使用<font color="#63ca87">Object.defineProperty()</font>。接收三个参数，属性所在对象、属性名、描述符对象。</p><p>描述符对象的属性：configurable(能否delete或修改属性特性)、enumerable(for-in能否返回属性)、writable(能否修改属性值)、value(属性的数据值)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">  writable:<span class="literal">false</span>,</span><br><span class="line">  value:<span class="string">'Jack'</span></span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">'Rose'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//Jack</span></span><br></pre></td></tr></table></figure><p>PS：configurable设置为false表示不可配置之后，就不能再变回可配置了，此时修改除writable之外的特性都会报错。</p><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>包含getter()和setter()。访问器属性必须用Object.defineProperty()定义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;<span class="attr">_year</span>:<span class="number">2004</span>,<span class="attr">edition</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">'year'</span>,&#123;</span><br><span class="line">  <span class="keyword">get</span>:function()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue;</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue <span class="number">-2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="定义多个属性和读取属性"><a href="#定义多个属性和读取属性" class="headerlink" title="定义多个属性和读取属性"></a>定义多个属性和读取属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    value:<span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year:&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">      <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> des = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">'_year'</span>);</span><br><span class="line">alert(des.value); <span class="comment">//2004</span></span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>为了解决构造函数和字面量创建对象的缺点：创建多个对象时代码重复</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>用函数来封装以特定接口创建对象的细节。缺点：无法识别对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"B"</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>与工厂模式的不同：没有显示的创建对象；直接将属性和方法赋予了this；没有return；函数名首字母大写；创建实例必须使用new操作符（构造函数与普通函数的调用方式不同）；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'A'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'B'</span>,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//可以将构造函数的实例标识为一种特定的类型（识别对象）</span></span><br></pre></td></tr></table></figure><p>缺点：每个方法都要在实例上重新创建一遍（不同实例的同名方法是不同的）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//优化:解决了两个函数调用同一方法的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点：可能需要定义多个全局函数</span></span><br></pre></td></tr></table></figure><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>prototype属性是一个指针，指向原型对象，通过调用构造函数创建的对象实例的原型对象。原型对象的优点：所有的实例都共享了包含的属性和方法。将对象实例的信息都添加到原型对象中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"A"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person2.name = <span class="string">"B"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//"A"--来自原型，说明不能通过实例重写原型中的值</span></span><br><span class="line">alert(person2.name);<span class="comment">//"B"--来自实例,屏蔽原型对象中同名的属性，切断了和原型的联系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hasOwnProperty检测属性是否在实例中</span></span><br><span class="line"><span class="built_in">console</span>.log( person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in 判断对象是否能访问该属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.keys()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype));  <span class="comment">//['name','age','sayName']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person2));  <span class="comment">//['name']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype));</span><br><span class="line"><span class="comment">//['constructor','name','age','sayName']</span></span><br><span class="line"></span><br><span class="line">person2.name = <span class="literal">null</span>;</span><br><span class="line">alert(person2.name);<span class="comment">//""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person2.name; <span class="comment">//删除实例属性</span></span><br><span class="line">alert(person2.name);<span class="comment">//"A" --来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//Person.prototype指向原型，Person.prototype.constructor指向Person</span></span><br></pre></td></tr></table></figure><p>for-in循环时返回的是所有对象能够访问的属性（包括原型中的属性）。如果要获取所有可枚举属性，可以使用<font color="#63ca87">Object.keys()</font>，返回数组。如果要获取所有实例属性，不论是否可枚举，使用<font color="#63ca87">Object.getOwnPropertyNames()</font>。</p><p>缺点：原型的共享性会导致实例的引用类型值相同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="comment">//字面量的方式重写原型对象，会切断现有实例和新原型的联系</span></span><br><span class="line">  <span class="keyword">constructor</span>:Person,//指向Person</span><br><span class="line">  name:'A',</span><br><span class="line">  age:20,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  friends:[<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">//b,c,d</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">//b,c,d</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends == person2.friends); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造模式用于实例属性，原型模式用于定义方法和共享的属性。可以用来定义引用类型的一种默认模式。（推荐）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"a"</span>,<span class="string">"b"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>:Person,</span><br><span class="line">	sayName:function()&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"B"</span>,<span class="number">28</span>);</span><br><span class="line">person1.friends.push(<span class="string">"c"</span>);</span><br><span class="line">alert(person1.friends === person2.friends);<span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>信息封装在构造函数中，通过构造函数初始化原型。不能使用字面量重写原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> Person(<span class="string">"C"</span>,<span class="number">30</span>);</span><br><span class="line">person3.sayName();</span><br></pre></td></tr></table></figure><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>这个模式可以在特殊情况下用来为对象创建构造函数。不能依赖instanceof确定对象类型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;<span class="comment">//封装创建对象并返回新对象</span></span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>和寄生构造函数类似，不同点：新创建对象的实例方法不引用this，不使用new操作符调用构造函数。(在安全的环境中使用)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"A"</span>,<span class="number">20</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型链是实现继承的主要方法。在继承时不能使用字面量创建原型。原型链的基本模式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getSuper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承Super</span></span><br><span class="line"><span class="comment">//让原型对象等于另一个类型的实例</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.getSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuper()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>缺点：引用类型值会被所有实例共享；在创建子类型时不能给超类型的构造函数传递参数。</p><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>在子类型构造函数内部调用超类型构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承</span></span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.nums.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.nums); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.nums); <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>子类型构造函数像超类型构造函数传递参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承</span></span><br><span class="line">  Super.call(<span class="keyword">this</span>,<span class="string">'A'</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name,instance.age);</span><br><span class="line"><span class="comment">//'A',20</span></span><br></pre></td></tr></table></figure><p>缺点：不支持函数复用；超类型的原型中定义的方法对子类型不可见；</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。（推荐）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承</span></span><br><span class="line">  Super.call(<span class="keyword">this</span>,name);<span class="comment">//第一次调用Super</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//第二次调用Super</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'A'</span>,<span class="number">20</span>);</span><br><span class="line">instance1.nums.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.nums); <span class="comment">//[1,2,3,4]</span></span><br><span class="line">instance1.sayName(); <span class="comment">//A</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'B'</span>,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.nums); <span class="comment">//[1,2,3]</span></span><br><span class="line">instance2.sayName(); <span class="comment">//B</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>缺点：无论怎样都会调用两次超类型构造函数</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型基于已有对象创建新对象。可以用方法<font color="#63ca87">Object.create()</font>实现。参数：用作新对象原型的对象、为新对象定义额外属性的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name :<span class="string">'A'</span>,</span><br><span class="line">  nums:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line">person1.nums.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">'person2'</span>;</span><br><span class="line">person2.nums.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.nums);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">  name:&#123;</span><br><span class="line">    value:<span class="string">'person3'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person3.name);<span class="comment">//person3</span></span><br></pre></td></tr></table></figure><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>和寄生构造函数类似。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>通过借用构造函数继承属性，通过原型链的混合形式来继承方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">sub,super</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(<span class="keyword">super</span>.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = sub;</span><br><span class="line">  sub.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>,name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Sub,Super);</span><br><span class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>函数声明，函数表达式。函数表达式创建的函数是匿名函数。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>有权访问另一个函数作用域中的变量的函数。</p><p>作用域链是一个指向变量对象的指针列表，只引用但不包含变量对象。闭包保存的是包含函数的整个活动变量，所以闭包只能取得包含函数中任何变量是最后一个值。</p><p>闭包中的this对象：this对象指向函数的执行环境。匿名对象的执行环境具有全局性，所以this对象指向window。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> object =&#123;</span><br><span class="line">  name:<span class="string">'object'</span>,</span><br><span class="line">  getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//闭包</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()); <span class="comment">//'window'</span></span><br><span class="line"><span class="built_in">console</span>.log(object.sayName()); <span class="comment">//'object'</span></span><br></pre></td></tr></table></figure><p>把外部作用域的this保存在闭包能访问到的变量中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> object =&#123;</span><br><span class="line">  name:<span class="string">'object'</span>,</span><br><span class="line">  getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _this.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()); <span class="comment">//'object'</span></span><br></pre></td></tr></table></figure><h4 id="模仿块级作用域和私有变量"><a href="#模仿块级作用域和私有变量" class="headerlink" title="模仿块级作用域和私有变量"></a>模仿块级作用域和私有变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//私有作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>任何在函数内部定义的变量都是私有变量。特权方法：有权访问私有变量和私有函数的方法。<br>创建特权方法：</p><ol><li>在构造函数中定义<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//特权方法（闭包）</span></span><br><span class="line">  <span class="keyword">this</span>.publicFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    val++;</span><br><span class="line">    <span class="keyword">return</span> privateFun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.publicFun());</span><br></pre></td></tr></table></figure></li></ol><p>缺点：每个实例都会创建同样的方法<br>2. 静态私有变量：在私有作用域中定义私有变量<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">var</span> privateval = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  MyObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//初始化未经声明的变量会创建一个全局变量，可以在私有作用域外被访问到（严格模式下报错）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//特权方法</span></span><br><span class="line">  MyObj.prototype.publicFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    privateval++;</span><br><span class="line">    <span class="keyword">return</span> privateFun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p></p><p>缺点：每个实例都共享了方法，但没有自己的私有变量<br>3. 模块模式：为单例创建私有变量和特权方法，单例是只有一个实例的对象<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个对象并对其初始化，并公开一些访问私有数据的方法</span></span><br><span class="line"><span class="keyword">var</span> single - <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateval = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//特权方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicproperty:<span class="literal">true</span>,</span><br><span class="line">    publicFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      privateval++;</span><br><span class="line">      <span class="keyword">return</span> privateFun();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="浏览器对象模型（BOM）"><a href="#浏览器对象模型（BOM）" class="headerlink" title="浏览器对象模型（BOM）"></a>浏览器对象模型（BOM）</h3><p>BOM的核心是window。</p><h4 id="全局对象和window对象"><a href="#全局对象和window对象" class="headerlink" title="全局对象和window对象"></a>全局对象和window对象</h4><p>全局变量是window对象的属性。全局变量不能通过delete删除，但直接在window上定义的属性可以删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.color); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oldvalue);<span class="comment">//报错</span></span><br><span class="line"><span class="built_in">console</span>.log(windwo.oldvalue); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><p>保存当前窗口的文档信息。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析查询url</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryArgs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//取得查询字符串并去除开头问号</span></span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">''</span>),</span><br><span class="line">  args = &#123;&#125;,</span><br><span class="line">  items = qs.length ? qs.split(<span class="string">"&amp;"</span>):[],</span><br><span class="line">  item = <span class="literal">null</span>,</span><br><span class="line">  name = <span class="literal">null</span>,</span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = items.length;i &lt; len; i++)&#123;</span><br><span class="line">    item = items[i].split(<span class="string">'='</span>);</span><br><span class="line">    name = decodeURLComponent(item[<span class="number">0</span>]);<span class="comment">//解码</span></span><br><span class="line">    value = decodeURLComponent(item[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(name.length)&#123;</span><br><span class="line">      args[name] = valuel</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用location对象可以改变浏览器的位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.assign(url);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="built_in">window</span>.location = url;</span><br><span class="line">location.href = url;</span><br><span class="line"></span><br><span class="line">location.replace(url);</span><br><span class="line"><span class="comment">//不在历史记录中生成新纪录，不能回退</span></span><br><span class="line"></span><br><span class="line">location.reload(); <span class="comment">//重新加载页面（可能从缓存中加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//从服务器重新加载页面</span></span><br></pre></td></tr></table></figure><h4 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h4><p>保存浏览器信息。</p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在ie中无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = name.toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> plugins = navigator.plugins,</span><br><span class="line">    len = plugins.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hasPlugin(<span class="string">"Flash"</span>));</span><br></pre></td></tr></table></figure><h4 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h4><ul><li>screen对象：显示器信息</li><li>history对象：历史记录<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>); <span class="comment">//后退一页</span></span><br><span class="line">history.back();</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">1</span>); <span class="comment">//前进一页</span></span><br><span class="line">history.forward();</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>); <span class="comment">//前进两页</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="string">"baidu.com"</span>); <span class="comment">//跳到最近的baidu.com</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h4 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h4><p>检测浏览器是否支持某功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasNSPlugins = !!( navigator.plugins&amp;&amp; navigator.plugins.length);</span><br></pre></td></tr></table></figure><h4 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h4><p>针对浏览器的特殊行为进行检测。</p><h4 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h4><h3 id="文档对象模型（DOM）"><a href="#文档对象模型（DOM）" class="headerlink" title="文档对象模型（DOM）"></a>文档对象模型（DOM）</h3><p>针对XML扩展后用于HTML的应用程序编程接口(API)。DOM把页面映射为一个多层节点结构，或者说它将网页中的HTML文档抽象为内存中的节点对象树(DOM Tree)。树中的每一个节点对象对应HTML文档中的一个元素。</p><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><p>有12种节点类型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType == <span class="number">1</span>)&#123;<span class="comment">//元素节点</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"element"</span>);</span><br><span class="line">  <span class="keyword">var</span> name = someNode.nodeName; <span class="comment">//元素的标签名</span></span><br><span class="line">  <span class="keyword">var</span> value = someNode.nodeValue; <span class="comment">//null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(someNode.nodeType == <span class="number">3</span>)&#123;<span class="comment">//文本节点</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"text"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>节点关系</li></ol><p>每个节点都有childNodes属性，保存着NodeList对象（类数组对象，保存一组有序的节点）。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> len = someNode.childNodes.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);<span class="comment">//转化为数组</span></span><br><span class="line"><span class="comment">//更完善的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArr</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    array = <span class="built_in">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,len = nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">      array.push(nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = someNode.parentNode;</span><br><span class="line"><span class="keyword">var</span> next = someNode.nextSibling;</span><br><span class="line"><span class="keyword">var</span> prev = someNode.previousSibling;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasChildNodes(someNode)); <span class="comment">//是否有子节点</span></span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>操作节点</li></ol><p><font color="#63ca87">appendChild()</font>：向childNodes末尾添加节点，返回新增节点。如果节点已经存在，就把它移动到末尾。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = someNode.appendChild(someNode.firstChild);</span><br><span class="line"><span class="built_in">console</span>.log(node == someNode.firstChild); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p><font color="#63ca87">insertBefore()</font>：向指定位置插入节点，返回新增节点。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入最后一个子节点</span></span><br><span class="line"><span class="keyword">var</span> node = someNode.insertBefore(newNode,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> node = someNode.insertBefore(newNode,someNode.firstChild);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入最后一个子节点之前</span></span><br><span class="line"><span class="keyword">var</span> node = someNode.insertBefore(newNode,someNode.lastChild);</span><br></pre></td></tr></table></figure><p></p><p><font color="#63ca87">replaceChild()</font>：替换节点。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> node = someNode.replaceChild(newNode,someNode.firstChild);</span><br></pre></td></tr></table></figure><p></p><p><font color="#63ca87">removeChild()</font>：移除节点。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> node = someNode.removeChild(someNode.firstChild);</span><br></pre></td></tr></table></figure><p></p><p><font color="#63ca87">cloneNode()</font>：复制节点，接收一个布尔参数，表示是否深复制。深复制：复制节点及其子节点；浅复制：仅复制节点。<br><font color="#63ca87">normalize()</font>：处理文本节点（删除空文本节点，合并相邻文本节点）</p><h4 id="document类型"><a href="#document类型" class="headerlink" title="document类型"></a>document类型</h4><p>表示文档，表示html页面。nodeType值为9，nodeName为#document。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.firstChild); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype; <span class="comment">//有浏览器兼容性问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL; <span class="comment">//完整的url</span></span><br><span class="line"><span class="keyword">var</span> dimain = <span class="built_in">document</span>.dimain; <span class="comment">//域名(可设置)</span></span><br><span class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer; <span class="comment">//来源页面的url</span></span><br></pre></td></tr></table></figure><ol><li>查找元素</li></ol><p><font color="#63ca87">getElementById()</font>：返回第一次匹配的元素。在ie7中可能返回name特性的元素。<br><font color="#63ca87">getElementByTagName()</font>：根据标签名查找元素，返回包含零或多个元素的NodeList。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementByTagName(<span class="string">"img"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(imgs.length);</span><br><span class="line"><span class="built_in">console</span>.log(imgs[<span class="number">0</span>].src);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="built_in">console</span>.log(imgs.item(<span class="number">0</span>).src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//namedItem: 通过name特性取得元素</span></span><br><span class="line"><span class="keyword">var</span> myimg = imgs.namedItem(<span class="string">"myimg"</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">var</span> myimg = imgs[<span class="string">"myimg"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> all = <span class="built_in">document</span>.getElementByTagName(<span class="string">"*"</span>);<span class="comment">//所有标签</span></span><br></pre></td></tr></table></figure><p></p><p><font color="#63ca87">getElementByName()</font>：根据name特性返回所有元素<br>2. 特殊集合</p><p><font color="#63ca87">document.anchors</font>：所有带name特性的&lt;a&gt;元素。</p><p><font color="#63ca87">document.forms</font>：所有&lt;form&gt;。</p><p><font color="#63ca87">document.images</font>：所有&lt;img&gt;。</p><p><font color="#63ca87">document.links</font>：所有带href特性的&lt;a&gt;元素。<br>3. DOM一致性检测</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>,<span class="string">"1.0"</span>);</span><br><span class="line"><span class="comment">//参数：检测的DOM功能名称和版本号</span></span><br></pre></td></tr></table></figure><ol start="4"><li>文档写入</li></ol><p><font color="#63ca87">document.write()</font>：写入s输出流。</p><p><font color="#63ca87">document.writeln()</font>：写入时加换行符。</p><p><font color="#63ca87">document.open()</font>：打开输出流。</p><p><font color="#63ca87">document.close()</font>：关闭输出流。</p><h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4><p>nodeType值为1。可以用nodeName或者tagName获取元素标签名，在html中标签名以大写返回。</p><ol><li>HTML元素</li></ol><p>特性：id,title,lang(语言),dir(方向),className<br>2. 操作特性</p><p>特性的名称不区分大小写。<br><font color="#63ca87">getAttribute(attrname)</font>：获取某特性，返回字符串</p><p><font color="#63ca87">setAttribute(attrname,attrvalue)</font>：设置特性</p><p><font color="#63ca87">removeAttribute(attrname)</font>：移除特性<br>3. attributes属性</p><p>Element类型有attributes属性。包含元素所有的属性Attr节点，可以用nodeName获取特性的名称，nodeValue获取特性值。一般用于遍历元素的特性。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">"id"</span>].nodeValue;</span><br><span class="line"><span class="comment">//setNamedItem()：添加特性；removeNamedItem()：移除特性；item(index)：查找特性</span></span><br><span class="line"><span class="keyword">if</span>(element.attributes[<span class="string">"id"</span>].specified)&#123;</span><br><span class="line">  <span class="comment">//是否指定的该特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="4"><li>创建元素<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      <categories>
        <category>笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
